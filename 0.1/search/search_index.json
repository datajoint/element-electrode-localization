{"config": {"lang": ["en"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Element Electrode Localization", "text": "<p>DataJoint Element for localizing Neuropixels electrodes within the Allen brain atlas -  Allen Mouse Common Coordinate Framework (CCF). DataJoint  Elements collectively standardize and automate data collection and analysis for  neuroscience experiments. Each Element is a modular pipeline for data storage and  processing with corresponding database tables that can be combined with other Elements  to assemble a fully functional pipeline.</p>"}, {"location": "#experiment-flowchart", "title": "Experiment Flowchart", "text": ""}, {"location": "#data-pipeline", "title": "Data Pipeline", "text": ""}, {"location": "#getting-started", "title": "Getting Started", "text": "<ul> <li>Install from PyPI<pre><code>pip install element-electrode-localization\n</code></pre> </li> </ul> <ul> <li>Data Pipeline - Pipeline and table descriptions</li> </ul> <ul> <li>Tutorials - Start building your data pipeline</li> </ul> <ul> <li>Concepts - Key partnerships and roadmap</li> </ul> <ul> <li>Code Repository</li> </ul>"}, {"location": "changelog/", "title": "Changelog", "text": "<p>Observes Semantic Versioning standard and Keep a Changelog convention.</p>"}, {"location": "changelog/#015-2023-05-11", "title": "0.1.5 - 2023-05-11", "text": "<ul> <li>Fix - <code>.ipynb</code> dark mode output for all notebooks.</li> </ul>"}, {"location": "changelog/#014-2023-04-28", "title": "0.1.4 - 2023-04-28", "text": "<ul> <li>Fix - <code>.ipynb</code> output in tutorials is not visible in dark mode.</li> </ul>"}, {"location": "changelog/#013-2023-04-06", "title": "0.1.3 - 2023-04-06", "text": "<ul> <li>Add - Notebook rendering in docs</li> <li>Add - Pre-commit, cspell, and markdown linters</li> <li>Update - Docs and readme</li> </ul>"}, {"location": "changelog/#012-2022-10-21", "title": "0.1.2 - 2022-10-21", "text": "<ul> <li>Add - mkdocs deployment with workflow API docs</li> </ul>"}, {"location": "changelog/#011-2022-10-11", "title": "0.1.1 - 2022-10-11", "text": "<ul> <li>Add - CICD workflows for PyPI release</li> </ul>"}, {"location": "changelog/#010-2022-05-10", "title": "0.1.0 - 2022-05-10", "text": "<ul> <li>Add - Table architecture reflecting precursor projects</li> <li>Add - Loaders for CCF atlas and channel locations json files</li> <li>Add - Adopted black formatting into code base</li> </ul>"}, {"location": "citation/", "title": "Citation", "text": "<p>If your work uses this Element, please cite the following manuscript and Research Resource Identifier (RRID).</p> <ul> <li>Yatsenko D, Nguyen T, Shen S, Gunalan K, Turner CA, Guzman R, Sasaki M, Sitonic D,   Reimer J, Walker EY, Tolias AS. DataJoint Elements: Data Workflows for   Neurophysiology. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.03.30.437358</li> </ul> <ul> <li>DataJoint Element Electrode Localization - RRID:SCR_021894 - Version 0.1.5</li> </ul>"}, {"location": "concepts/", "title": "Concepts", "text": ""}, {"location": "concepts/#modeling-the-brain", "title": "Modeling the Brain", "text": "<p>Studies of brain anatomy and cellular morphology were once confined to single-subject studies wherein in vitro slices were compared to develop a complete model of the brain. With dyes, researchers could compare recordings to the reconstructed location of a given recording device. Through clever experimental design, researchers could further associate highly localized regions to their task-dependent function. Advances in 3D modeling have permitted parallel advances in multi-subject averaged anatomical atlases,  which serve as a shared reference frame to study functional neuroanatomy. The Allen Institute has been a leader in the development of such mouse atlases since 2007  (Lein et al., Nature 2007;  Wang et al., Cell 2020).</p>"}, {"location": "concepts/#key-partnerships", "title": "Key Partnerships", "text": "<p>Labs have developed project-specific DataJoint pipelines for pairing the coordinates of recording electrodes with the location in published atlases. The DataJoint team collaborated with several and interviewed these teams to understand their experiment workflow, associated tools, and interfaces. These teams include:</p> <ul> <li>Mesoscale Activity Project</li> <li>International Brain Lab</li> </ul>"}, {"location": "concepts/#element-roadmap", "title": "Element Roadmap", "text": "<p>Through our interviews and direct collaboration on the key projects, we identified the common motifs to create Element Electrode Localization with the repository hosted on GitHub. Further development of this Element is community driven. Upon user requests we will continue adding features to this Element, such as improved region- and subregion-based topological referencing.</p> <ul> <li> <p> Generalize the table architecture from existing project-specific pipelines:</p> <ul> <li> International Brain Laboratory's  iblapps</li> </ul> <ul> <li> Allen Institute's atlas files</li> </ul> </li> </ul>"}, {"location": "pipeline/", "title": "Data Pipeline", "text": "<p>Each of the DataJoint Elements are a set of tables for common neuroinformatics modalities to organize, preprocess, and analyze data. Each node in the following diagram is either a table in the Element itself or a table that would be connected to the Element.</p> <p></p> <p>The Element is separated into two schemas:</p> <ul> <li><code>coordinate_framework</code> ingests standard atlases and retains voxel-based lookup tables,   including references to brain regions, acronyms, and standardized color   codes.</li> </ul> <ul> <li><code>electrode_localization</code> pairs the above reference tables with Neuropixels electrode   location data from the Element Array Ephys probe schema.</li> </ul>"}, {"location": "pipeline/#coordinate_framework-schema-api-docs", "title": "<code>coordinate_framework</code> schema (API docs)", "text": "Table Description CCF Common coordinate framework (CCF) identifier, version, resolution, and description. CCF.Voxel CCF voxel coordinates. BrainRegionAnnotation Name and voxels of each brain region associated with an atlas. BrainRegionAnnotation.BrainRegion Brain region name, acronym, identifier, and color code. BrainRegionAnnotation.Voxel Voxels associated with each brain region. ParentBrainRegion Hierarchical structure between the brain regions. <ul> <li>Note: Acronyms in DataJoint do not perfectly map on to the Allen Institute's published standard. By default, DataJoint databases are not case sensitive. Instead, acronyms are converted to snake case to avoid naming collisions. While we depart from the standard, preliminary interviews with users indicate no bias toward the official standard. Visit the tutorial Jupyter notebook for a demonstration of converting between the case sensitive and snake case standards.</li> </ul>"}, {"location": "pipeline/#electrode_localization-schema-api-docs", "title": "<code>electrode_localization</code> schema (API docs)", "text": "Table Description ElectrodePosition CCF voxels associated with a given probe insertion. ElectrodePosition.Electrode CCF voxels associated with each electrode."}, {"location": "api/make_pages/", "title": "Make pages", "text": "In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the api pages and navigation.\nNOTE: Works best when following the Google style guide\nhttps://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html\nhttps://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings\n\"\"\"\n</pre> \"\"\"Generate the api pages and navigation. NOTE: Works best when following the Google style guide https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings \"\"\" In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\nfrom pathlib import Path\nimport os\nimport subprocess\n</pre> import mkdocs_gen_files from pathlib import Path import os import subprocess In\u00a0[\u00a0]: Copied! <pre>package = os.getenv(\"PACKAGE\")\n</pre> package = os.getenv(\"PACKAGE\") In\u00a0[\u00a0]: Copied! <pre>element = package.split(\"_\", 1)[1]\nif not Path(f\"workflow_{element}\").is_dir():\n    try:\n        subprocess.run(\n            f\"git clone https://github.com/datajoint/workflow-{element.replace('_','-')}.git /main/delete\".split(\n                \" \"\n            ),\n            check=True,\n            timeout=5,\n        )\n        os.system(f\"mv /main/delete/workflow_{element} /main/\")\n        os.system(\"rm -fR /main/delete\")\n    except subprocess.CalledProcessError:\n        pass  # no repo found\n</pre> element = package.split(\"_\", 1)[1] if not Path(f\"workflow_{element}\").is_dir():     try:         subprocess.run(             f\"git clone https://github.com/datajoint/workflow-{element.replace('_','-')}.git /main/delete\".split(                 \" \"             ),             check=True,             timeout=5,         )         os.system(f\"mv /main/delete/workflow_{element} /main/\")         os.system(\"rm -fR /main/delete\")     except subprocess.CalledProcessError:         pass  # no repo found In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(package).glob(\"**/*.py\")) + sorted(\n    Path(f\"workflow_{element}\").glob(\"**/*.py\")\n):\n    if path.stem == \"__init__\":\n        continue\n    with mkdocs_gen_files.open(f\"api/{path.with_suffix('')}.md\", \"w\") as f:\n        module_path = \".\".join(\n            [p for p in path.with_suffix(\"\").parts if p != \"__init__\"]\n        )\n        print(f\"::: {module_path}\", file=f)\n    nav[path.parts] = f\"{path.with_suffix('')}.md\"\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(package).glob(\"**/*.py\")) + sorted(     Path(f\"workflow_{element}\").glob(\"**/*.py\") ):     if path.stem == \"__init__\":         continue     with mkdocs_gen_files.open(f\"api/{path.with_suffix('')}.md\", \"w\") as f:         module_path = \".\".join(             [p for p in path.with_suffix(\"\").parts if p != \"__init__\"]         )         print(f\"::: {module_path}\", file=f)     nav[path.parts] = f\"{path.with_suffix('')}.md\" In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"api/navigation.md\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"api/navigation.md\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}, {"location": "api/element_electrode_localization/coordinate_framework/", "title": "coordinate_framework.py", "text": ""}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.activate", "title": "<code>activate(schema_name, *, create_schema=True, create_tables=True)</code>", "text": "<p>Activates the schema.</p> <p>Parameters:</p> Name Type Description Default <code>schema_name</code> <code>str</code> <p>A string containing the name of the probe schema.</p> required <code>create_schema</code> <code>bool</code> <p>If True, schema will be created in the database.</p> <code>True</code> <code>create_tables</code> <code>bool</code> <p>If True, tables related to the schema will be created in the database.</p> <code>True</code> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>def activate(schema_name, *, create_schema=True, create_tables=True):\n\"\"\"Activates the schema.\n\n    Args:\n        schema_name (str): A string containing the name of the probe schema.\n        create_schema (bool): If True, schema will be created in the database.\n        create_tables (bool): If True, tables related to the schema will be created in the database.\n    \"\"\"\n    schema.activate(\n        schema_name, create_schema=create_schema, create_tables=create_tables\n    )\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.CCF", "title": "<code>CCF</code>", "text": "<p>         Bases: <code>dj.Lookup</code></p> <p>Common coordinate framework information.</p> <p>Attributes:</p> Name Type Description <code>ccf_id</code> <code>foreign key, int</code> <p>CCF ID/atlas ID.</p> <code>ccf_version</code> <code>varchar(64)</code> <p>Allen CCF version.</p> <code>ccf_resolution</code> <code>float</code> <p>Voxel resolution in microns.</p> <code>ccf_description</code> <code>varchar(255)</code> <p>CCF label descriptions.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>@schema\nclass CCF(dj.Lookup):\n\"\"\"Common coordinate framework information.\n\n    Attributes:\n        ccf_id (foreign key, int): CCF ID/atlas ID.\n        ccf_version (varchar(64) ): Allen CCF version.\n        ccf_resolution (float): Voxel resolution in microns.\n        ccf_description (varchar(255) ): CCF label descriptions.\n    \"\"\"\n\n    definition = \"\"\"  # Common Coordinate Framework\n    ccf_id            : int             # CCF ID, a.k.a atlas ID\n    ---\n    ccf_version       : varchar(64)     # Allen CCF Version - e.g. CCFv3\n    ccf_resolution    : float           # voxel resolution in micron\n    ccf_description='': varchar(255)    # CCFLabel Description\n    \"\"\"\n\n    class Voxel(dj.Part):\n\"\"\"CCF voxel coordinates.\n\n        Attributes:\n            CCF (foreign key): CCF primary key.\n            x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers.\n            y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers.\n            z (foreign key, int): Left-to-right (ML axis) in micrometers.\n        \"\"\"\n\n        definition = \"\"\"  # CCF voxel coordinates\n        -&gt; master\n        x   :  int   # (um)  Anterior-to-Posterior (AP axis)\n        y   :  int   # (um)  Superior-to-Inferior (DV axis)\n        z   :  int   # (um)  Left-to-Right (ML axis)\n        index(y, z)\n        \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.CCF.Voxel", "title": "<code>Voxel</code>", "text": "<p>         Bases: <code>dj.Part</code></p> <p>CCF voxel coordinates.</p> <p>Attributes:</p> Name Type Description <code>CCF</code> <code>foreign key</code> <p>CCF primary key.</p> <code>x</code> <code>foreign key, int</code> <p>Anterior-to-posterior axis (AP axis) in micrometers.</p> <code>y</code> <code>foreign key, int</code> <p>Superior-to_inferior axis (DV axis) in micrometers.</p> <code>z</code> <code>foreign key, int</code> <p>Left-to-right (ML axis) in micrometers.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>class Voxel(dj.Part):\n\"\"\"CCF voxel coordinates.\n\n    Attributes:\n        CCF (foreign key): CCF primary key.\n        x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers.\n        y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers.\n        z (foreign key, int): Left-to-right (ML axis) in micrometers.\n    \"\"\"\n\n    definition = \"\"\"  # CCF voxel coordinates\n    -&gt; master\n    x   :  int   # (um)  Anterior-to-Posterior (AP axis)\n    y   :  int   # (um)  Superior-to-Inferior (DV axis)\n    z   :  int   # (um)  Left-to-Right (ML axis)\n    index(y, z)\n    \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation", "title": "<code>BrainRegionAnnotation</code>", "text": "<p>         Bases: <code>dj.Lookup</code></p> <p>Brain region annotation.</p> <p>Attributes:</p> Name Type Description <code>CCF</code> <code>foreign key</code> <p>CCF primary key.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>@schema\nclass BrainRegionAnnotation(dj.Lookup):\n\"\"\"Brain region annotation.\n\n    Attributes:\n        CCF (foreign key): CCF primary key.\n    \"\"\"\n\n    definition = \"\"\"\n    -&gt; CCF\n    \"\"\"\n\n    class BrainRegion(dj.Part):\n\"\"\"Brain region information.\n\n        Attributes:\n            BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key.\n            acronym (foreign key, varchar(32) ): Brain region acronym.\n            region_name (varchar(128) ): Brain region full name.\n            region_id (int): Brain region ID.\n            color_code (varchar(6) ): Hex code of the color code for this region.\n        \"\"\"\n\n        definition = \"\"\"\n        -&gt; master\n        acronym: varchar(32)  # CHARACTER SET utf8 COLLATE utf8_bin\n        ---\n        region_name: varchar(128)\n        region_id=null: int\n        color_code=null: varchar(6)  # Hex code of the color code of this region\n        \"\"\"\n\n    class Voxel(dj.Part):\n\"\"\"Voxel information from CCF.\n\n        Attributes:\n            BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key.\n            CCF.Voxel (foreign key): CCF.Voxel primary key.\n        \"\"\"\n\n        definition = \"\"\"\n        -&gt; master.BrainRegion\n        -&gt; CCF.Voxel\n        \"\"\"\n\n    @classmethod\n    def retrieve_acronym(self, acronym):\n\"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\"\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", acronym).lower()\n\n    @classmethod\n    def voxel_query(self, x=None, y=None, z=None):\n\"\"\"Given one or more coordinates, return unique brain regions\n\n        Args:\n            x (float): x coordinate.\n            y (float): y coordinate.\n            z (float): z coordinate.\n\n        Raises:\n            ValueError: Must specificy at least one dimension.\n            NotImplementedError: Coming soon.\n        \"\"\"\n        if not any(x, y, z):\n            raise ValueError(\"Must specify at least one dimension\")\n        # query = self.Voxel  #  TODO: add utility function name lookup\n        raise NotImplementedError(\"Coming soon\")\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.BrainRegion", "title": "<code>BrainRegion</code>", "text": "<p>         Bases: <code>dj.Part</code></p> <p>Brain region information.</p> <p>Attributes:</p> Name Type Description <code>BrainRegionAnnotation</code> <code>foreign key</code> <p>BrainRegionAnnotation primary key.</p> <code>acronym</code> <code>foreign key, varchar(32) </code> <p>Brain region acronym.</p> <code>region_name</code> <code>varchar(128)</code> <p>Brain region full name.</p> <code>region_id</code> <code>int</code> <p>Brain region ID.</p> <code>color_code</code> <code>varchar(6)</code> <p>Hex code of the color code for this region.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>class BrainRegion(dj.Part):\n\"\"\"Brain region information.\n\n    Attributes:\n        BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key.\n        acronym (foreign key, varchar(32) ): Brain region acronym.\n        region_name (varchar(128) ): Brain region full name.\n        region_id (int): Brain region ID.\n        color_code (varchar(6) ): Hex code of the color code for this region.\n    \"\"\"\n\n    definition = \"\"\"\n    -&gt; master\n    acronym: varchar(32)  # CHARACTER SET utf8 COLLATE utf8_bin\n    ---\n    region_name: varchar(128)\n    region_id=null: int\n    color_code=null: varchar(6)  # Hex code of the color code of this region\n    \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.Voxel", "title": "<code>Voxel</code>", "text": "<p>         Bases: <code>dj.Part</code></p> <p>Voxel information from CCF.</p> <p>Attributes:</p> Name Type Description <code>BrainRegion</code> <code>foreign key</code> <p>BrainRegionAnnotation.BrainRegion primary key.</p> <code>CCF.Voxel</code> <code>foreign key</code> <p>CCF.Voxel primary key.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>class Voxel(dj.Part):\n\"\"\"Voxel information from CCF.\n\n    Attributes:\n        BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key.\n        CCF.Voxel (foreign key): CCF.Voxel primary key.\n    \"\"\"\n\n    definition = \"\"\"\n    -&gt; master.BrainRegion\n    -&gt; CCF.Voxel\n    \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.retrieve_acronym", "title": "<code>retrieve_acronym(acronym)</code>  <code>classmethod</code>", "text": "<p>Retrieve the DataJoint translation of the CCF acronym</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>@classmethod\ndef retrieve_acronym(self, acronym):\n\"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\"\n    return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", acronym).lower()\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.voxel_query", "title": "<code>voxel_query(x=None, y=None, z=None)</code>  <code>classmethod</code>", "text": "<p>Given one or more coordinates, return unique brain regions</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x coordinate.</p> <code>None</code> <code>y</code> <code>float</code> <p>y coordinate.</p> <code>None</code> <code>z</code> <code>float</code> <p>z coordinate.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Must specificy at least one dimension.</p> <code>NotImplementedError</code> <p>Coming soon.</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>@classmethod\ndef voxel_query(self, x=None, y=None, z=None):\n\"\"\"Given one or more coordinates, return unique brain regions\n\n    Args:\n        x (float): x coordinate.\n        y (float): y coordinate.\n        z (float): z coordinate.\n\n    Raises:\n        ValueError: Must specificy at least one dimension.\n        NotImplementedError: Coming soon.\n    \"\"\"\n    if not any(x, y, z):\n        raise ValueError(\"Must specify at least one dimension\")\n    # query = self.Voxel  #  TODO: add utility function name lookup\n    raise NotImplementedError(\"Coming soon\")\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.ParentBrainRegion", "title": "<code>ParentBrainRegion</code>", "text": "<p>         Bases: <code>dj.Lookup</code></p> <p>Hierarchical structure between the brain regions.</p> <p>Attributes:</p> Name Type Description <code>BrainRegionAnnotation.BrainRegion</code> <code>foreign key</code> <p>BrainRegionAnnotation.BrainRegion primary key.</p> <code>Parent</code> <code>query</code> <p>parent brain region acronym from BrainRegion table</p> Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>@schema\nclass ParentBrainRegion(dj.Lookup):\n\"\"\"Hierarchical structure between the brain regions.\n\n    Attributes:\n        BrainRegionAnnotation.BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key.\n        Parent (query): parent brain region acronym from BrainRegion table\n    \"\"\"\n\n    definition = \"\"\" # Hierarchical structure between the brain regions\n    -&gt; BrainRegionAnnotation.BrainRegion\n    ---\n    -&gt; BrainRegionAnnotation.BrainRegion.proj(parent='acronym')\n    \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.load_ccf_annotation", "title": "<code>load_ccf_annotation(ccf_id, version_name, voxel_resolution, nrrd_filepath, ontology_csv_filepath)</code>", "text": "<p>Load CCF annotation.</p> <p>For an example Allen brain atlas for mouse, see: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017 For the structure/ontology tree, see: https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359 (particularly the ontology file downloadable as CSV)</p> <p>Parameters:</p> Name Type Description Default <code>ccf_id</code> <code>int</code> <p>unique id to identify a new CCF dataset to be inserted.</p> required <code>version_name</code> <code>str</code> <p>CCF version.</p> required <code>voxel_resolution</code> <code>float</code> <p>voxel resolution in microns.</p> required <code>nrrd_filepath</code> <code>str</code> <p>path to the .nrrd file for the volume data.</p> required <code>ontology_csv_filepath</code> <code>str</code> <p>path to the .csv file for the brain region ontology.</p> required Source code in <code>element_electrode_localization/coordinate_framework.py</code> <pre><code>def load_ccf_annotation(\n    ccf_id, version_name, voxel_resolution, nrrd_filepath, ontology_csv_filepath\n):\n\"\"\"Load CCF annotation.\n\n    For an example Allen brain atlas for mouse, see:\n    http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017\n    For the structure/ontology tree, see:\n    https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359\n    (particularly the ontology file downloadable as CSV)\n\n    Args:\n        ccf_id (int): unique id to identify a new CCF dataset to be inserted.\n        version_name (str): CCF version.\n        voxel_resolution (float): voxel resolution in microns.\n        nrrd_filepath (str): path to the .nrrd file for the volume data.\n        ontology_csv_filepath (str): path to the .csv file for the brain region ontology.\n    \"\"\"\n    ccf_key = {\"ccf_id\": ccf_id}\n    if CCF &amp; ccf_key:\n        print(f\"CCF ID {ccf_id} already exists!\")\n        return\n\n    nrrd_filepath = pathlib.Path(nrrd_filepath)\n    ontology_csv_filepath = pathlib.Path(ontology_csv_filepath)\n\n    def to_snake_case(s):\n        return re.sub(r\"(?&lt;!^)(?=[A-Z])\", \"_\", s).lower()\n\n    ontology = pd.read_csv(ontology_csv_filepath)\n\n    stack, hdr = nrrd.read(nrrd_filepath.as_posix())  # AP (x), DV (y), ML (z)\n\n    log.info(\n        \".. loaded atlas brain volume of shape \" + f\"{stack.shape} from {nrrd_filepath}\"\n    )\n\n    ccf_key = {\"ccf_id\": ccf_id}\n    ccf_entry = {\n        **ccf_key,\n        \"ccf_version\": version_name,\n        \"ccf_resolution\": voxel_resolution,\n        \"ccf_description\": (\n            f\"Version: {version_name}\"\n            + f\" - Voxel resolution (uM): {voxel_resolution}\"\n            + f\" - Volume file: {nrrd_filepath.name}\"\n            + \" - Region ontology file: \"\n            + ontology_csv_filepath.name\n        ),\n    }\n\n    with dj.conn().transaction:\n        CCF.insert1(ccf_entry)\n        BrainRegionAnnotation.insert1(ccf_key)\n        BrainRegionAnnotation.BrainRegion.insert(\n            [\n                dict(\n                    ccf_id=ccf_id,\n                    acronym=to_snake_case(r.acronym),\n                    region_id=r.id,\n                    region_name=r.safe_name,\n                    color_code=r.color_hex_triplet,\n                )\n                for _, r in ontology.iterrows()\n            ]\n        )\n\n        # Process voxels per brain region\n        for idx, (region_id, r) in enumerate(tqdm(ontology.iterrows())):\n            dj.conn().ping()\n            region_id = int(region_id)\n\n            log.info(\n                \".. loading region {} ({}/{}) ({})\".format(\n                    region_id, idx, len(ontology), r.safe_name\n                )\n            )\n\n            # extracting filled volumes from stack in scaled [[x,y,z]] shape,\n            vol = np.array(np.where(stack == region_id)).T * voxel_resolution\n            vol = pd.DataFrame(vol, columns=[\"x\", \"y\", \"z\"])\n\n            if not vol.shape[0]:\n                log.info(\n                    \".. region {} volume: shape {} - skipping\".format(\n                        region_id, vol.shape\n                    )\n                )\n                continue\n            else:\n                log.info(\".. region {} volume: shape {}\".format(region_id, vol.shape))\n\n            vol[\"ccf_id\"] = [ccf_key[\"ccf_id\"]] * len(vol)\n            CCF.Voxel.insert(vol)\n\n            vol[\"acronym\"] = [to_snake_case(r.acronym)] * len(vol)\n            BrainRegionAnnotation.Voxel.insert(vol)\n\n    log.info(\".. done.\")\n</code></pre>"}, {"location": "api/element_electrode_localization/electrode_localization/", "title": "electrode_localization.py", "text": ""}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.activate", "title": "<code>activate(electrode_localization_schema_name, coordinate_framework_schema_name=None, *, create_schema=True, create_tables=True, linking_module=None)</code>", "text": "<p>Activates the <code>electrode_localization</code> and <code>coordinate_framework</code> schemas.</p> <p>Parameters:</p> Name Type Description Default <code>electrode_localization_schema_name</code> <code>str</code> <p>A string containing the name of the electrode_localization schema.</p> required <code>coordinate_framework_schema_name</code> <code>str</code> <p>A string containing the name of the coordinate_framework schema.</p> <code>None</code> <code>create_schema</code> <code>bool</code> <p>If True, schema will be created in the database.</p> <code>True</code> <code>create_tables</code> <code>bool</code> <p>If True, tables related to the schema will be created in the database.</p> <code>True</code> <code>linking_module</code> <code>str</code> <p>A string containing the module name or module containing the required dependencies to activate the schema.</p> <code>None</code> Source code in <code>element_electrode_localization/electrode_localization.py</code> <pre><code>def activate(\n    electrode_localization_schema_name,\n    coordinate_framework_schema_name=None,\n    *,\n    create_schema=True,\n    create_tables=True,\n    linking_module=None,\n):\n\"\"\"Activates the `electrode_localization` and `coordinate_framework` schemas.\n\n    Args:\n        electrode_localization_schema_name (str): A string containing the name of the\n            electrode_localization schema.\n        coordinate_framework_schema_name (str): A string containing the name of the coordinate_framework schema.\n        create_schema (bool): If True, schema will be created in the database.\n        create_tables (bool): If True, tables related to the schema will be created in the database.\n        linking_module (str): A string containing the module name or module containing the required dependencies to activate the schema.\n    \"\"\"\n\n    if isinstance(linking_module, str):\n        linking_module = importlib.import_module(linking_module)\n    assert inspect.ismodule(\n        linking_module\n    ), \"The argument 'dependency' must be a module's name or a module\"\n\n    global _linking_module, ProbeInsertion, probe\n    _linking_module = linking_module\n    ProbeInsertion = _linking_module.ProbeInsertion\n    probe = _linking_module.probe\n\n    # activate\n    coordinate_framework.activate(\n        coordinate_framework_schema_name,\n        create_schema=create_schema,\n        create_tables=create_tables,\n    )\n    schema.activate(\n        electrode_localization_schema_name,\n        create_schema=create_schema,\n        create_tables=create_tables,\n        add_objects=_linking_module.__dict__,\n    )\n</code></pre>"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.get_electrode_localization_dir", "title": "<code>get_electrode_localization_dir(probe_insertion_key)</code>", "text": "<p>Retrieve the electrode localization directory associated with a ProbeInsertion.</p> <p>The directory should contain <code>channel_locations.json</code> files (one per shank)for the corresponding <code>probe_insertion_key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>probe_insertion_key</code> <code>dict</code> <p>key of a ProbeInsertion.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The full file-path of the electrode localization dir.</p> Source code in <code>element_electrode_localization/electrode_localization.py</code> <pre><code>def get_electrode_localization_dir(probe_insertion_key: dict) -&gt; str:\n\"\"\"Retrieve the electrode localization directory associated with a ProbeInsertion.\n\n    The directory should contain `channel_locations.json` files (one per shank)for the corresponding `probe_insertion_key`.\n\n    Args:\n        probe_insertion_key (dict): key of a ProbeInsertion.\n\n    Returns:\n        The full file-path of the electrode localization dir.\n    \"\"\"\n    return _linking_module.get_electrode_localization_dir(probe_insertion_key)\n</code></pre>"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition", "title": "<code>ElectrodePosition</code>", "text": "<p>         Bases: <code>dj.Imported</code></p> <p>Electrode position information for a probe insertion.</p> <p>Attributes:</p> Name Type Description <code>ProbeInsertion</code> <code>foreign key</code> <p>ProbeInsertion primary key.</p> <code>coodinate_framework.CCF</code> <code>foreign key</code> <p>coordinate_framework.CCF primary key.</p> Source code in <code>element_electrode_localization/electrode_localization.py</code> <pre><code>@schema\nclass ElectrodePosition(dj.Imported):\n\"\"\"Electrode position information for a probe insertion.\n\n    Attributes:\n        ProbeInsertion (foreign key): ProbeInsertion primary key.\n        coodinate_framework.CCF (foreign key): coordinate_framework.CCF primary key.\n    \"\"\"\n\n    definition = \"\"\"\n    -&gt; ProbeInsertion\n    -&gt; coordinate_framework.CCF\n    \"\"\"\n\n    class Electrode(dj.Part):\n\"\"\"Voxel information for a given electrode.\n\n        Attributes:\n            master (foreign key): ElectrodePosition primary key.\n            probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key.\n            coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema.\n        \"\"\"\n\n        definition = \"\"\"\n        -&gt; master\n        -&gt; probe.ProbeType.Electrode\n        ---\n        -&gt; coordinate_framework.CCF.Voxel\n        \"\"\"\n\n    def make(self, key):\n\"\"\"Populates electrode position tables.\"\"\"\n        skipped_electrode_count = 0\n        voxel_resolution = (coordinate_framework.CCF &amp; key).fetch1(\"ccf_resolution\")\n        electrode_location_dir = pathlib.Path(get_electrode_localization_dir(key))\n        assert electrode_location_dir.exists()\n\n        channel_locations_files = list(\n            electrode_location_dir.glob(\"*channel_locations*.json\")\n        )\n\n        electrodes_query = (\n            probe.ProbeType.Electrode * probe.Probe * ProbeInsertion &amp; key\n        )\n        probe_type = (probe.Probe * ProbeInsertion &amp; key).fetch1(\"probe_type\")\n\n        shanks = np.unique(electrodes_query.fetch(\"shank\"))\n\n        if len(channel_locations_files) == 1:\n            corresponding_shanks = [0]\n            if len(shanks) != 1:\n                raise ValueError(\n                    \"Only 1 file found ({}) for a {}-shank probe\".format(\n                        channel_locations_files[0].name, len(shanks)\n                    )\n                )\n            if (\n                \"shank\" in channel_locations_files[0].stem\n                and channel_locations_files[0].stem[-1] != 1\n            ):\n                raise ValueError(\n                    \"The electrode-location file found ({}) is \"\n                    + \"unexpected for this 1-shank probe\"\n                )\n        else:\n            if len(channel_locations_files) != len(shanks):  # ensure 1 file per shank\n                raise ValueError(\n                    f\"{len(channel_locations_files)} files found for a \"\n                    + f\"{len(shanks)}-shank probe\"\n                )\n            corresponding_shanks = [int(f.stem[-1]) for f in channel_locations_files]\n\n        # Insertion\n        self.insert1(key)\n\n        for channel_locations_file, shank_no in zip(\n            channel_locations_files, corresponding_shanks\n        ):\n\n            log.debug(f\"loading channel locations from {channel_locations_file}\")\n            with open(channel_locations_file, \"r\") as fh:\n                chn_loc_raw = json.loads(fh.read())\n\n            chn_loc_data = {\"origin\": chn_loc_raw[\"origin\"]}\n\n            if len(chn_loc_data[\"origin\"]) &gt; 1:\n                log.error(\n                    \"More than one origin region found ({}). skipping.\".format(\n                        chn_loc_data[\"origin\"]\n                    )\n                )\n                raise ValueError(\n                    \"More than one origin region found \" + f'({chn_loc_data[\"origin\"]})'\n                )\n\n            # ensuring channel data is sorted;\n            chn_loc_keymap = {\n                int(k.split(\"_\")[1]): k for k in chn_loc_raw if \"channel_\" in k\n            }\n\n            chn_loc_data[\"channels\"] = np.array(\n                [\n                    tuple(chn_loc_raw[chn_loc_keymap[k]].values())\n                    for k in sorted(chn_loc_keymap)\n                ],\n                dtype=[\n                    (\"x\", float),\n                    (\"y\", float),\n                    (\"z\", float),\n                    (\"axial\", float),\n                    (\"lateral\", float),\n                    (\"brain_region_id\", int),\n                    (\"brain_region\", object),\n                ],\n            )\n\n            # get/scale xyz positions\n            pos_xyz_raw = np.array(\n                [chn_loc_data[\"channels\"][i] for i in (\"x\", \"y\", \"z\")]\n            ).T\n\n            pos_origin = next(iter(chn_loc_data[\"origin\"].values()))\n\n            pos_xyz = np.copy(pos_xyz_raw)\n\n            # by adjusting xyz axes &amp; offsetting from origin position\n            # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below\n            pos_xyz[:, 0] = pos_origin[1] - pos_xyz_raw[:, 1]\n            pos_xyz[:, 1] = pos_origin[0] + pos_xyz_raw[:, 0]\n            pos_xyz[:, 2] = pos_origin[2] - pos_xyz_raw[:, 2]\n\n            # and quantizing to CCF voxel resolution;\n            pos_xyz = (voxel_resolution * np.around(pos_xyz / voxel_resolution)).astype(\n                int\n            )\n\n            # get recording geometry,\n            probe_electrodes = (electrodes_query &amp; {\"shank\": shank_no}).fetch(\n                order_by=\"electrode asc\"\n            )\n\n            rec_electrodes = np.array(\n                [chn_loc_data[\"channels\"][\"lateral\"], chn_loc_data[\"channels\"][\"axial\"]]\n            ).T\n\n            # adjusting for the lateral offset\n            # npx 1.0 probes has an alternating offset of 0um and 16um between the rows\n            # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows)\n            lateral_offset = np.abs(\n                np.diff(\n                    (\n                        electrodes_query\n                        &amp; {\"shank_col\": 1, \"shank\": shank_no}\n                        &amp; \"shank_row in (1, 2)\"\n                    ).fetch(\"x_coord\")\n                )[0]\n            )\n            if lateral_offset:\n                rec_electrodes[:, 0] = lateral_offset * (\n                    np.floor(rec_electrodes[:, 0] / lateral_offset)\n                )\n\n            # to find corresponding electrodes,\n            elec_coord = np.array(\n                [probe_electrodes[\"x_coord\"], probe_electrodes[\"y_coord\"]]\n            ).T\n\n            elec_coord_map = {tuple(c): i for i, c in enumerate(elec_coord)}\n\n            rec_to_elec_idx = np.array(\n                [elec_coord_map[tuple(i)] for i in rec_electrodes]\n            )\n\n            for electrode, x, y, z in zip(\n                probe_electrodes[rec_to_elec_idx][\"electrode\"],\n                pos_xyz[:, 0],\n                pos_xyz[:, 1],\n                pos_xyz[:, 2],\n            ):\n                entry = {\n                    **key,\n                    \"electrode\": electrode,\n                    \"x\": x,\n                    \"y\": y,\n                    \"z\": z,\n                    \"probe_type\": probe_type,\n                }\n                try:\n                    self.Electrode.insert1(entry)\n                except dj.IntegrityError as e:\n                    skipped_electrode_count += 1\n                    log.warning(\n                        \"...... ElectrodePositionError at X=\"\n                        + f\"{x}, Y={y}, Z={z}:\\n {repr(e)}\"\n                    )\n        if skipped_electrode_count &gt; 0:\n            log.info(f\"Skipped {skipped_electrode_count} electrodes for \\n\\t{key}\")\n</code></pre>"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition.Electrode", "title": "<code>Electrode</code>", "text": "<p>         Bases: <code>dj.Part</code></p> <p>Voxel information for a given electrode.</p> <p>Attributes:</p> Name Type Description <code>master</code> <code>foreign key</code> <p>ElectrodePosition primary key.</p> <code>probe.ProbeType.Electrode</code> <code>foreign key</code> <p>probe.ProbeType.Electrode primary key.</p> <code>coordinate_framework.CCF.Voxel</code> <code>query</code> <p>fetches Voxel information from coordinate_framework schema.</p> Source code in <code>element_electrode_localization/electrode_localization.py</code> <pre><code>class Electrode(dj.Part):\n\"\"\"Voxel information for a given electrode.\n\n    Attributes:\n        master (foreign key): ElectrodePosition primary key.\n        probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key.\n        coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema.\n    \"\"\"\n\n    definition = \"\"\"\n    -&gt; master\n    -&gt; probe.ProbeType.Electrode\n    ---\n    -&gt; coordinate_framework.CCF.Voxel\n    \"\"\"\n</code></pre>"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition.make", "title": "<code>make(key)</code>", "text": "<p>Populates electrode position tables.</p> Source code in <code>element_electrode_localization/electrode_localization.py</code> <pre><code>def make(self, key):\n\"\"\"Populates electrode position tables.\"\"\"\n    skipped_electrode_count = 0\n    voxel_resolution = (coordinate_framework.CCF &amp; key).fetch1(\"ccf_resolution\")\n    electrode_location_dir = pathlib.Path(get_electrode_localization_dir(key))\n    assert electrode_location_dir.exists()\n\n    channel_locations_files = list(\n        electrode_location_dir.glob(\"*channel_locations*.json\")\n    )\n\n    electrodes_query = (\n        probe.ProbeType.Electrode * probe.Probe * ProbeInsertion &amp; key\n    )\n    probe_type = (probe.Probe * ProbeInsertion &amp; key).fetch1(\"probe_type\")\n\n    shanks = np.unique(electrodes_query.fetch(\"shank\"))\n\n    if len(channel_locations_files) == 1:\n        corresponding_shanks = [0]\n        if len(shanks) != 1:\n            raise ValueError(\n                \"Only 1 file found ({}) for a {}-shank probe\".format(\n                    channel_locations_files[0].name, len(shanks)\n                )\n            )\n        if (\n            \"shank\" in channel_locations_files[0].stem\n            and channel_locations_files[0].stem[-1] != 1\n        ):\n            raise ValueError(\n                \"The electrode-location file found ({}) is \"\n                + \"unexpected for this 1-shank probe\"\n            )\n    else:\n        if len(channel_locations_files) != len(shanks):  # ensure 1 file per shank\n            raise ValueError(\n                f\"{len(channel_locations_files)} files found for a \"\n                + f\"{len(shanks)}-shank probe\"\n            )\n        corresponding_shanks = [int(f.stem[-1]) for f in channel_locations_files]\n\n    # Insertion\n    self.insert1(key)\n\n    for channel_locations_file, shank_no in zip(\n        channel_locations_files, corresponding_shanks\n    ):\n\n        log.debug(f\"loading channel locations from {channel_locations_file}\")\n        with open(channel_locations_file, \"r\") as fh:\n            chn_loc_raw = json.loads(fh.read())\n\n        chn_loc_data = {\"origin\": chn_loc_raw[\"origin\"]}\n\n        if len(chn_loc_data[\"origin\"]) &gt; 1:\n            log.error(\n                \"More than one origin region found ({}). skipping.\".format(\n                    chn_loc_data[\"origin\"]\n                )\n            )\n            raise ValueError(\n                \"More than one origin region found \" + f'({chn_loc_data[\"origin\"]})'\n            )\n\n        # ensuring channel data is sorted;\n        chn_loc_keymap = {\n            int(k.split(\"_\")[1]): k for k in chn_loc_raw if \"channel_\" in k\n        }\n\n        chn_loc_data[\"channels\"] = np.array(\n            [\n                tuple(chn_loc_raw[chn_loc_keymap[k]].values())\n                for k in sorted(chn_loc_keymap)\n            ],\n            dtype=[\n                (\"x\", float),\n                (\"y\", float),\n                (\"z\", float),\n                (\"axial\", float),\n                (\"lateral\", float),\n                (\"brain_region_id\", int),\n                (\"brain_region\", object),\n            ],\n        )\n\n        # get/scale xyz positions\n        pos_xyz_raw = np.array(\n            [chn_loc_data[\"channels\"][i] for i in (\"x\", \"y\", \"z\")]\n        ).T\n\n        pos_origin = next(iter(chn_loc_data[\"origin\"].values()))\n\n        pos_xyz = np.copy(pos_xyz_raw)\n\n        # by adjusting xyz axes &amp; offsetting from origin position\n        # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below\n        pos_xyz[:, 0] = pos_origin[1] - pos_xyz_raw[:, 1]\n        pos_xyz[:, 1] = pos_origin[0] + pos_xyz_raw[:, 0]\n        pos_xyz[:, 2] = pos_origin[2] - pos_xyz_raw[:, 2]\n\n        # and quantizing to CCF voxel resolution;\n        pos_xyz = (voxel_resolution * np.around(pos_xyz / voxel_resolution)).astype(\n            int\n        )\n\n        # get recording geometry,\n        probe_electrodes = (electrodes_query &amp; {\"shank\": shank_no}).fetch(\n            order_by=\"electrode asc\"\n        )\n\n        rec_electrodes = np.array(\n            [chn_loc_data[\"channels\"][\"lateral\"], chn_loc_data[\"channels\"][\"axial\"]]\n        ).T\n\n        # adjusting for the lateral offset\n        # npx 1.0 probes has an alternating offset of 0um and 16um between the rows\n        # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows)\n        lateral_offset = np.abs(\n            np.diff(\n                (\n                    electrodes_query\n                    &amp; {\"shank_col\": 1, \"shank\": shank_no}\n                    &amp; \"shank_row in (1, 2)\"\n                ).fetch(\"x_coord\")\n            )[0]\n        )\n        if lateral_offset:\n            rec_electrodes[:, 0] = lateral_offset * (\n                np.floor(rec_electrodes[:, 0] / lateral_offset)\n            )\n\n        # to find corresponding electrodes,\n        elec_coord = np.array(\n            [probe_electrodes[\"x_coord\"], probe_electrodes[\"y_coord\"]]\n        ).T\n\n        elec_coord_map = {tuple(c): i for i, c in enumerate(elec_coord)}\n\n        rec_to_elec_idx = np.array(\n            [elec_coord_map[tuple(i)] for i in rec_electrodes]\n        )\n\n        for electrode, x, y, z in zip(\n            probe_electrodes[rec_to_elec_idx][\"electrode\"],\n            pos_xyz[:, 0],\n            pos_xyz[:, 1],\n            pos_xyz[:, 2],\n        ):\n            entry = {\n                **key,\n                \"electrode\": electrode,\n                \"x\": x,\n                \"y\": y,\n                \"z\": z,\n                \"probe_type\": probe_type,\n            }\n            try:\n                self.Electrode.insert1(entry)\n            except dj.IntegrityError as e:\n                skipped_electrode_count += 1\n                log.warning(\n                    \"...... ElectrodePositionError at X=\"\n                    + f\"{x}, Y={y}, Z={z}:\\n {repr(e)}\"\n                )\n    if skipped_electrode_count &gt; 0:\n        log.info(f\"Skipped {skipped_electrode_count} electrodes for \\n\\t{key}\")\n</code></pre>"}, {"location": "api/element_electrode_localization/version/", "title": "version.py", "text": "<p>Package metadata.</p>"}, {"location": "tutorials/", "title": "Tutorials", "text": ""}, {"location": "tutorials/#installation", "title": "Installation", "text": "<pre><code>pip install element-electrode-localization\n</code></pre> <ul> <li>See the User Instructions page to  install the integrated development environment and database.</li> </ul> <ul> <li>These instructions use the example workflow for Element Array Ephys, which can be modified for a user's specific experimental requirements. This example workflow uses several Elements (Lab, Animal, Session, Event, Electrophysiology, and Electrode Localization) to construct a complete pipeline, and is able to store experimental data and run data analysis.</li> </ul>"}, {"location": "tutorials/#notebooks", "title": "Notebooks", "text": "<p>The Electrode Localization notebook is part of a larger tutorial series on Element Array Ephys. To run this notebook, be sure to download the data and configure your settings.</p>"}, {"location": "tutorials/08-electrode-localization/", "title": "Notebook", "text": "<p>Change into the parent directory to find the <code>dj_local_conf.json</code> file.</p> In\u00a0[\u00a0]: Copied! <pre># change to the upper level folder to detect dj_local_conf.json\nimport os\nif os.path.basename(os.getcwd()) == \"notebooks\":\n    os.chdir(\"..\")\n</pre> # change to the upper level folder to detect dj_local_conf.json import os if os.path.basename(os.getcwd()) == \"notebooks\":     os.chdir(\"..\") In\u00a0[\u00a0]: Copied! <pre># We'll be working with long tables, so we'll make visualization easier with a limit\nimport datajoint as dj\ndj.config[\"display.limit\"] = 10\n</pre> # We'll be working with long tables, so we'll make visualization easier with a limit import datajoint as dj dj.config[\"display.limit\"] = 10 <p>The Allen Institute hosts brain atlases and ontology trees that we'll use in the next section. The <code>localization.py</code> script assumes this is your first atlas, and that you'll use the 100\u03bcm resolution. For finer resolutions, edit <code>voxel_resolution</code> in <code>localization.py</code>. Higher resolution <code>nrrd</code> files are quite large when loaded. Depending on the python environment, the terminal may be killed when loading so much information into memory. To load multiple atlases, increment <code>ccf_id</code> for each unique atlas.</p> <p>To run this pipeline ...</p> <ol> <li>Download the 100\u03bcm <code>nrrd</code> and <code>csv</code> files from the links above.</li> <li>Move these files to your ephys root directory.</li> </ol> <p>Next, we'll populate the coordinate framework schema simply by loading it. Because we are loading the whole brain volume, this may take 25 minutes or more.</p> In\u00a0[2]: Copied! <pre>from workflow_array_ephys.localization import coordinate_framework as ccf\n</pre> from workflow_array_ephys.localization import coordinate_framework as ccf <pre>Connecting cbroz@dss-db.datajoint.io:3306\n</pre> In\u00a0[3]: Copied! <pre>dj.Diagram(ccf)\n</pre> dj.Diagram(ccf) Out[3]: 3 3 ccf.ParentBrainRegion ccf.ParentBrainRegion 3-&gt;ccf.ParentBrainRegion ccf.BrainRegionAnnotation.BrainRegion ccf.BrainRegionAnnotation.BrainRegion ccf.BrainRegionAnnotation.BrainRegion-&gt;3 ccf.BrainRegionAnnotation.BrainRegion-&gt;ccf.ParentBrainRegion ccf.BrainRegionAnnotation.Voxel ccf.BrainRegionAnnotation.Voxel ccf.BrainRegionAnnotation.BrainRegion-&gt;ccf.BrainRegionAnnotation.Voxel ccf.CCF.Voxel ccf.CCF.Voxel ccf.CCF.Voxel-&gt;ccf.BrainRegionAnnotation.Voxel ccf.CCF ccf.CCF ccf.CCF-&gt;ccf.CCF.Voxel ccf.BrainRegionAnnotation ccf.BrainRegionAnnotation ccf.CCF-&gt;ccf.BrainRegionAnnotation ccf.BrainRegionAnnotation-&gt;ccf.BrainRegionAnnotation.BrainRegion <p>Now, to explore the data we just loaded.</p> In\u00a0[3]: Copied! <pre>ccf.BrainRegionAnnotation.BrainRegion()\n</pre> ccf.BrainRegionAnnotation.BrainRegion() Out[3]: <p>ccf_id</p> CCF ID, a.k.a atlas ID <p>acronym</p> CHARACTER SET utf8 COLLATE utf8_bin <p>region_name</p> <p>region_id</p> <p>color_code</p> hexcode of the color code of this region 0 6b Layer 6b isocortex 16 8ADA870 a_a_a Anterior amygdalar area 23 80C0E20 a_c_a Anterior cingulate area 31 40A6660 a_c_a1 Anterior cingulate area layer 1 572 40A6660 a_c_a2/3 Anterior cingulate area layer 2/3 1053 40A6660 a_c_a5 Anterior cingulate area layer 5 739 40A6660 a_c_a6a Anterior cingulate area layer 6a 179 40A6660 a_c_a6b Anterior cingulate area layer 6b 227 40A6660 a_c_ad Anterior cingulate area dorsal part 39 40A6660 a_c_ad1 Anterior cingulate area dorsal part layer 1 935 40A666 <p>...</p> <p>Total: 1327</p> <p>The acronyms listed in the DataJoint table differ slightly from the CCF standard by substituting case-sensitive differences with snake case. To lookup the snake case equivalent, use the <code>retrieve_acronym</code> function.</p> In\u00a0[4]: Copied! <pre>central_thalamus = ccf.BrainRegionAnnotation.retrieve_acronym(\"CM\")\ncranial_nerves = ccf.BrainRegionAnnotation.retrieve_acronym(\"cm\")\nprint(f\"CM: {central_thalamus}\\ncm: {cranial_nerves}\")\n</pre> central_thalamus = ccf.BrainRegionAnnotation.retrieve_acronym(\"CM\") cranial_nerves = ccf.BrainRegionAnnotation.retrieve_acronym(\"cm\") print(f\"CM: {central_thalamus}\\ncm: {cranial_nerves}\") <pre>CM: c_m\ncm: cm\n</pre> <p>If your work requires the case-sensitive columns please get in touch with the DataJoint team via StackOverflow.</p> <p>For this demo, let's look at the dimensions of the central thalamus. To look at other regions, open the CSV you downloaded and search for your desired region.</p> In\u00a0[10]: Copied! <pre>cm_voxels = ccf.BrainRegionAnnotation.Voxel() &amp; f'acronym=\"{central_thalamus}\"'\ncm_voxels\n</pre> cm_voxels = ccf.BrainRegionAnnotation.Voxel() &amp; f'acronym=\"{central_thalamus}\"' cm_voxels Out[10]: <p>ccf_id</p> CCF ID, a.k.a atlas ID <p>acronym</p> CHARACTER SET utf8 COLLATE utf8_bin <p>x</p> (um)  Anterior-to-Posterior (AP axis) <p>y</p> (um)  Superior-to-Inferior (DV axis) <p>z</p> (um)  Left-to-Right (ML axis) 0 c_m 100 3300 49000 c_m 100 3300 50000 c_m 100 3300 51000 c_m 100 3300 52000 c_m 100 3300 53000 c_m 100 3300 61000 c_m 100 3300 62000 c_m 100 3300 63000 c_m 100 3300 64000 c_m 100 3300 6500 <p>...</p> <p>Total: 4911</p> In\u00a0[17]: Copied! <pre>cm_x, cm_y, cm_z = cm_voxels.fetch(\"x\", \"y\", \"z\")\nprint(\n    f\"The central thalamus extends from \\n\\tx = {min(cm_x)}  to x = {max(cm_x)}\\n\\t\"\n    + f\"y = {min(cm_y)} to y = {max(cm_y)}\\n\\tz = {min(cm_z)} to z = {max(cm_z)}\"\n)\n</pre> cm_x, cm_y, cm_z = cm_voxels.fetch(\"x\", \"y\", \"z\") print(     f\"The central thalamus extends from \\n\\tx = {min(cm_x)}  to x = {max(cm_x)}\\n\\t\"     + f\"y = {min(cm_y)} to y = {max(cm_y)}\\n\\tz = {min(cm_z)} to z = {max(cm_z)}\" ) <pre>The central thalamus extends from \n\tx = 100  to x = 8400\n\ty = 2600 to y = 7500\n\tz = 1700 to z = 9700\n</pre> <p>If you have <code>channel_location</code> json files for your data, you can look at the position and regions associated with each electrode. Here, we've added an example file to our pre-existing <code>subject6</code> for demonstration purposes.</p> In\u00a0[4]: Copied! <pre>from workflow_array_ephys.localization import coordinate_framework as ccf\nfrom workflow_array_ephys.localization import electrode_localization as eloc\n</pre> from workflow_array_ephys.localization import coordinate_framework as ccf from workflow_array_ephys.localization import electrode_localization as eloc In\u00a0[9]: Copied! <pre>(dj.Diagram(eloc) + dj.Diagram(ccf) - 1)\n</pre> (dj.Diagram(eloc) + dj.Diagram(ccf) - 1) Out[9]: 35 35 ccf.ParentBrainRegion ccf.ParentBrainRegion 35-&gt;ccf.ParentBrainRegion ccf.BrainRegionAnnotation.BrainRegion ccf.BrainRegionAnnotation.BrainRegion ccf.BrainRegionAnnotation.BrainRegion-&gt;35 ccf.BrainRegionAnnotation.BrainRegion-&gt;ccf.ParentBrainRegion ccf.BrainRegionAnnotation.Voxel ccf.BrainRegionAnnotation.Voxel ccf.BrainRegionAnnotation.BrainRegion-&gt;ccf.BrainRegionAnnotation.Voxel eloc.probe.ProbeType.Electrode eloc.probe.ProbeType.Electrode eloc.ElectrodePosition.Electrode eloc.ElectrodePosition.Electrode eloc.probe.ProbeType.Electrode-&gt;eloc.ElectrodePosition.Electrode ccf.CCF.Voxel ccf.CCF.Voxel ccf.CCF.Voxel-&gt;eloc.ElectrodePosition.Electrode ccf.CCF.Voxel-&gt;ccf.BrainRegionAnnotation.Voxel eloc.ProbeInsertion eloc.ProbeInsertion eloc.ElectrodePosition eloc.ElectrodePosition eloc.ProbeInsertion-&gt;eloc.ElectrodePosition ccf.CCF ccf.CCF ccf.CCF-&gt;ccf.CCF.Voxel ccf.BrainRegionAnnotation ccf.BrainRegionAnnotation ccf.CCF-&gt;ccf.BrainRegionAnnotation ccf.CCF-&gt;eloc.ElectrodePosition ccf.BrainRegionAnnotation-&gt;ccf.BrainRegionAnnotation.BrainRegion eloc.ElectrodePosition-&gt;eloc.ElectrodePosition.Electrode <p>Because the probe may not be fully inserted, there will be some electrode positions that occur outside the brain. We register these instances with an <code>IntegrityError</code> warning because we're trying to register a coordinate position with no corresponding location in the <code>ccf.CCF.Voxel</code> table. We can silence these warnings by setting the log level before running <code>populate()</code> on the <code>ElectrodePosition</code> table.</p> In\u00a0[\u00a0]: Copied! <pre>import logging\n</pre> import logging In\u00a0[3]: Copied! <pre>logging.getLogger().setLevel(logging.ERROR)  # or logging.INFO\n</pre> logging.getLogger().setLevel(logging.ERROR)  # or logging.INFO In\u00a0[\u00a0]: Copied! <pre>eloc.ElectrodePosition.populate()\n</pre> eloc.ElectrodePosition.populate() <p>By calling the <code>ElectrodePosition</code> table, we can see the keys the <code>populate()</code> method has already processed.</p> In\u00a0[6]: Copied! <pre>eloc.ElectrodePosition()\n</pre> eloc.ElectrodePosition() Out[6]: <p>subject</p> <p>session_datetime</p> <p>insertion_number</p> <p>ccf_id</p> CCF ID, a.k.a atlas ID subject5 2018-07-03 20:32:28 1 0subject5 2018-07-03 20:32:28 2 0subject6 2021-01-15 11:16:38 0 0 <p>Total: 3</p> <p>Let's focus on <code>subject5</code>, insertion <code>1</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from workflow_array_ephys.pipeline import ephys\n</pre> from workflow_array_ephys.pipeline import ephys In\u00a0[8]: Copied! <pre>key = (ephys.EphysRecording &amp; 'subject=\"subject5\"' &amp; \"insertion_number=1\").fetch1(\"KEY\")\nlen(eloc.ElectrodePosition.Electrode &amp; key)\n</pre> key = (ephys.EphysRecording &amp; 'subject=\"subject5\"' &amp; \"insertion_number=1\").fetch1(\"KEY\") len(eloc.ElectrodePosition.Electrode &amp; key) Out[8]: <pre>373</pre> <p>With a resolution of 100\u03bcm, adjacent electrodes will very likely be in the same region. Let's look at every 38th electrode to sample 10 across the probe.</p> <p>If you're interested in more electrodes, decrease the number next to the <code>%</code> modulo operator.</p> In\u00a0[13]: Copied! <pre>electrode_coordinates = (\n    eloc.ElectrodePosition.Electrode &amp; \"electrode%38=0\" &amp; key\n).fetch(\"electrode\", \"x\", \"y\", \"z\", as_dict=True)\nfor e in electrode_coordinates:\n    x, y, z = [e[k] for k in (\"x\", \"y\", \"z\")]\n    acronym = (ccf.BrainRegionAnnotation.Voxel &amp; f\"x={x}\" &amp; f\"y={y}\" &amp; f\"z={z}\").fetch1(\n        \"acronym\"\n    )\n    e[\"region\"] = (\n        ccf.BrainRegionAnnotation.BrainRegion &amp; f'acronym=\"{acronym}\"'\n    ).fetch1(\"region_name\")\n    print(\"Electrode {electrode} (x={x}, y={y}, z={z}) is in {region}\".format(**e))\n</pre> electrode_coordinates = (     eloc.ElectrodePosition.Electrode &amp; \"electrode%38=0\" &amp; key ).fetch(\"electrode\", \"x\", \"y\", \"z\", as_dict=True) for e in electrode_coordinates:     x, y, z = [e[k] for k in (\"x\", \"y\", \"z\")]     acronym = (ccf.BrainRegionAnnotation.Voxel &amp; f\"x={x}\" &amp; f\"y={y}\" &amp; f\"z={z}\").fetch1(         \"acronym\"     )     e[\"region\"] = (         ccf.BrainRegionAnnotation.BrainRegion &amp; f'acronym=\"{acronym}\"'     ).fetch1(\"region_name\")     print(\"Electrode {electrode} (x={x}, y={y}, z={z}) is in {region}\".format(**e)) <pre>Electrode 0 (x=11900, y=6300, z=6900) is in Primary auditory area\nElectrode 38 (x=11900, y=6300, z=6500) is in Primary auditory area\nElectrode 76 (x=11800, y=6300, z=6100) is in Declive (VI) Purkinje layer\nElectrode 114 (x=11700, y=6400, z=5600) is in Lobules IV-V molecular layer\nElectrode 152 (x=11700, y=6400, z=5200) is in Declive (VI) Purkinje layer\nElectrode 190 (x=11600, y=6500, z=4700) is in Primary auditory area\nElectrode 228 (x=11600, y=6500, z=4300) is in Granular lamina of the cochlear nuclei\nElectrode 266 (x=11600, y=6600, z=3900) is in Cuneiform nucleus\nElectrode 304 (x=11600, y=6600, z=3500) is in Lateral hypothalamic area\nElectrode 342 (x=11600, y=6700, z=3100) is in root\nElectrode 380 (x=11600, y=6700, z=2800) is in root\n</pre> In\u00a0[7]: Copied! <pre>eloc.ElectrodePosition.Electrode()\n</pre> eloc.ElectrodePosition.Electrode() Out[7]: <p>subject</p> <p>session_datetime</p> <p>insertion_number</p> <p>ccf_id</p> CCF ID, a.k.a atlas ID <p>probe_type</p> e.g. neuropixels_1.0 <p>electrode</p> electrode index, starts at 0 <p>x</p> (um)  Anterior-to-Posterior (AP axis) <p>y</p> (um)  Superior-to-Inferior (DV axis) <p>z</p> (um)  Left-to-Right (ML axis) subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 206 11000 4600 4600subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 207 11000 4600 4600subject6 2021-01-15 11:16:38 0 0 neuropixels 1.0 - 3B 206 11000 4600 4600subject6 2021-01-15 11:16:38 0 0 neuropixels 1.0 - 3B 207 11000 4600 4600subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 196 11000 4600 4700subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 197 11000 4600 4700subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 198 11000 4600 4700subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 199 11000 4600 4700subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 200 11000 4600 4700subject5 2018-07-03 20:32:28 2 0 neuropixels 1.0 - 3A 201 11000 4600 4700 <p>...</p> <p>Total: 1113</p>"}, {"location": "tutorials/08-electrode-localization/#electrode-localization", "title": "Electrode Localization\u00b6", "text": ""}, {"location": "tutorials/08-electrode-localization/#coordinate-framework", "title": "Coordinate Framework\u00b6", "text": ""}, {"location": "tutorials/08-electrode-localization/#electrode-localization", "title": "Electrode Localization\u00b6", "text": ""}]}