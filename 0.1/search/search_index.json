{"config": {"indexing": "full", "lang": ["en"], "min_search_length": 3, "prebuild_index": false, "separator": "[\\s\\-]+"}, "docs": [{"location": "", "text": "Element Electrode Localization \u00b6 This Element features DataJoint schemas for localizing Neuropixels electrodes within the Allen Mouse Common Coordinate Framework (CCF) . The Element consists of coordinate_framework and electrode_localization . Visit the Concepts page for more information about the use cases of this Element and an explanation of the tables.", "title": "Element Electrode Localization"}, {"location": "#element-electrode-localization", "text": "This Element features DataJoint schemas for localizing Neuropixels electrodes within the Allen Mouse Common Coordinate Framework (CCF) . The Element consists of coordinate_framework and electrode_localization . Visit the Concepts page for more information about the use cases of this Element and an explanation of the tables.", "title": "Element Electrode Localization"}, {"location": "changelog/", "text": "../../CHANGELOG.md", "title": "Changelog"}, {"location": "citation/", "text": "Citation \u00b6 If your work uses this Element, please cite the following manuscript and Research Resource Identifier (RRID). Yatsenko D, Nguyen T, Shen S, Gunalan K, Turner CA, Guzman R, Sasaki M, Sitonic D, Reimer J, Walker EY, Tolias AS. DataJoint Elements: Data Workflows for Neurophysiology. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.03.30.437358 DataJoint Elements ( RRID:SCR_021894 ) - Element Electrode Localization (version 0.1.2)", "title": "Citation"}, {"location": "citation/#citation", "text": "If your work uses this Element, please cite the following manuscript and Research Resource Identifier (RRID). Yatsenko D, Nguyen T, Shen S, Gunalan K, Turner CA, Guzman R, Sasaki M, Sitonic D, Reimer J, Walker EY, Tolias AS. DataJoint Elements: Data Workflows for Neurophysiology. bioRxiv. 2021 Jan 1. doi: https://doi.org/10.1101/2021.03.30.437358 DataJoint Elements ( RRID:SCR_021894 ) - Element Electrode Localization (version 0.1.2)", "title": "Citation"}, {"location": "concepts/", "text": "Concepts \u00b6 Modeling the Brain \u00b6 Studies of brain anatomy and cellular morphology were once confined to single-subject studies wherein in vitro slices were compared to develop a complete model of the brain. With dyes, researchers could compare recordings to the reconstructed location of a given recording device. Through clever experimental design, researchers could further associate highly localized regions to their task-dependent function. Advances in 3D modeling have permitted parallel advances in multi-subject averaged anatomical models. An atlas serves as a shared reference frame for a given species. The Allen Institute has been a leader in the development of mouse atlases since 2007 1 , with regular updates 2 that provide researchers with a shared reference frame in the study of functional neuroanatomy. Element Architecture \u00b6 Each of the DataJoint Elements are a set of tables for common neuroinformatics modalities to organize, preprocess, and analyze data. Each node in the following diagram is either a table in the Element itself or a table that would be connected to the Element. The Element is separated into two schemas: coordinate_framework ingests standard atlases and retains voxel-based lookup tables, including references to brain region information, acronyms and standardized color codes. electrode_localization pairs the above reference tables with Neuropixels probe location data in a probe schema, optionally from Element Array Ephys Key Partnerships \u00b6 In coordination with both the Mesoscale Activity Project and the International Brain Lab, DataJoint developed mechanisms for pairing recording coordinates with the published atlases in project-specific cases that have since been generalized. Pipeline Development and Limitations \u00b6 The Element's table architecture was generalized from existing project-specific pipelines such as International Brain Laboratory's iblapps as well as the Allen Institute's atlas files . One notable consession was made in development: acronyms in DataJoint do not perfectly map on to the Allen Institute's published standard. By default, DataJoint databases are not case sensitive. Instead, acronyms are convered to snake case to avoid naming collisions. While we depart from the standard, preliminary interviews with users indicate no bias toward the official standard. Visit our localization notebook for a demonstration of converting between the case sensitive and snake case standards. Roadmap \u00b6 Further development of this Element is community driven. Upon user requests we will continue adding features to this Element, such as improved region- and subregion-based topological referencing. References \u00b6 [1]: Lein, E. S., Hawrylycz, M. J., Ao, N., Ayres, M., Bensinger, A., Bernard, A., ... & Jones, A. R. (2007). Genome-wide atlas of gene expression in the adult mouse brain. Nature , 445(7124), 168-176. [2]: Wang, Q., Ding, S. L., Li, Y., Royall, J., Feng, D., Lesnar, P., ... & Ng, L. (2020). The Allen mouse brain common coordinate framework: a 3D reference atlas. Cell , 181(4), 936-953.", "title": "Concepts"}, {"location": "concepts/#concepts", "text": "", "title": "Concepts"}, {"location": "concepts/#modeling-the-brain", "text": "Studies of brain anatomy and cellular morphology were once confined to single-subject studies wherein in vitro slices were compared to develop a complete model of the brain. With dyes, researchers could compare recordings to the reconstructed location of a given recording device. Through clever experimental design, researchers could further associate highly localized regions to their task-dependent function. Advances in 3D modeling have permitted parallel advances in multi-subject averaged anatomical models. An atlas serves as a shared reference frame for a given species. The Allen Institute has been a leader in the development of mouse atlases since 2007 1 , with regular updates 2 that provide researchers with a shared reference frame in the study of functional neuroanatomy.", "title": "Modeling the Brain"}, {"location": "concepts/#element-architecture", "text": "Each of the DataJoint Elements are a set of tables for common neuroinformatics modalities to organize, preprocess, and analyze data. Each node in the following diagram is either a table in the Element itself or a table that would be connected to the Element. The Element is separated into two schemas: coordinate_framework ingests standard atlases and retains voxel-based lookup tables, including references to brain region information, acronyms and standardized color codes. electrode_localization pairs the above reference tables with Neuropixels probe location data in a probe schema, optionally from Element Array Ephys", "title": "Element Architecture"}, {"location": "concepts/#key-partnerships", "text": "In coordination with both the Mesoscale Activity Project and the International Brain Lab, DataJoint developed mechanisms for pairing recording coordinates with the published atlases in project-specific cases that have since been generalized.", "title": "Key Partnerships"}, {"location": "concepts/#pipeline-development-and-limitations", "text": "The Element's table architecture was generalized from existing project-specific pipelines such as International Brain Laboratory's iblapps as well as the Allen Institute's atlas files . One notable consession was made in development: acronyms in DataJoint do not perfectly map on to the Allen Institute's published standard. By default, DataJoint databases are not case sensitive. Instead, acronyms are convered to snake case to avoid naming collisions. While we depart from the standard, preliminary interviews with users indicate no bias toward the official standard. Visit our localization notebook for a demonstration of converting between the case sensitive and snake case standards.", "title": "Pipeline Development and Limitations"}, {"location": "concepts/#roadmap", "text": "Further development of this Element is community driven. Upon user requests we will continue adding features to this Element, such as improved region- and subregion-based topological referencing.", "title": "Roadmap"}, {"location": "concepts/#references", "text": "[1]: Lein, E. S., Hawrylycz, M. J., Ao, N., Ayres, M., Bensinger, A., Bernard, A., ... & Jones, A. R. (2007). Genome-wide atlas of gene expression in the adult mouse brain. Nature , 445(7124), 168-176. [2]: Wang, Q., Ding, S. L., Li, Y., Royall, J., Feng, D., Lesnar, P., ... & Ng, L. (2020). The Allen mouse brain common coordinate framework: a 3D reference atlas. Cell , 181(4), 936-953.", "title": "References"}, {"location": "tutorials/", "text": "Tutorials \u00b6 Coming soon!", "title": "Tutorials"}, {"location": "tutorials/#tutorials", "text": "Coming soon!", "title": "Tutorials"}, {"location": "api/element_electrode_localization/coordinate_framework/", "text": "BrainRegionAnnotation \u00b6 Bases: dj . Lookup Brain region annotation. Attributes: Name Type Description CCF foreign key CCF primary key. Source code in element_electrode_localization/coordinate_framework.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @schema class BrainRegionAnnotation ( dj . Lookup ): \"\"\"Brain region annotation. Attributes: CCF (foreign key): CCF primary key. \"\"\" definition = \"\"\" -> CCF \"\"\" class BrainRegion ( dj . Part ): \"\"\"Brain region information. Attributes: BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key. acronym (foreign key, varchar(32) ): Brain region acronym. region_name (varchar(128) ): Brain region full name. region_id (int): Brain region ID. color_code (varchar(6) ): Hexcode of the color code for this region. \"\"\" definition = \"\"\" -> master acronym: varchar(32) # CHARACTER SET utf8 COLLATE utf8_bin --- region_name: varchar(128) region_id=null: int color_code=null: varchar(6) # hexcode of the color code of this region \"\"\" class Voxel ( dj . Part ): \"\"\"Voxel information from CCF. Attributes: BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel (foreign key): CCF.Voxel primary key. \"\"\" definition = \"\"\" -> master.BrainRegion -> CCF.Voxel \"\"\" @classmethod def retrieve_acronym ( self , acronym ): \"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\" return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , acronym ) . lower () @classmethod def voxel_query ( self , x = None , y = None , z = None ): \"\"\"Given one or more coordinates, return unique brain regions Args: x (float): x coordinate. y (float): y coordinate. z (float): z coordinate. Raises: ValueError: Must specificy at least one dimension. NotImplementedError: Coming soon. \"\"\" if not any ( x , y , z ): raise ValueError ( \"Must specify at least one dimension\" ) # query = self.Voxel # TODO: add utility function name lookup raise NotImplementedError ( \"Coming soon\" ) BrainRegion \u00b6 Bases: dj . Part Brain region information. Attributes: Name Type Description BrainRegionAnnotation foreign key BrainRegionAnnotation primary key. acronym foreign key, varchar(32) Brain region acronym. region_name varchar (128) Brain region full name. region_id int Brain region ID. color_code varchar (6) Hexcode of the color code for this region. Source code in element_electrode_localization/coordinate_framework.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class BrainRegion ( dj . Part ): \"\"\"Brain region information. Attributes: BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key. acronym (foreign key, varchar(32) ): Brain region acronym. region_name (varchar(128) ): Brain region full name. region_id (int): Brain region ID. color_code (varchar(6) ): Hexcode of the color code for this region. \"\"\" definition = \"\"\" -> master acronym: varchar(32) # CHARACTER SET utf8 COLLATE utf8_bin --- region_name: varchar(128) region_id=null: int color_code=null: varchar(6) # hexcode of the color code of this region \"\"\" Voxel \u00b6 Bases: dj . Part Voxel information from CCF. Attributes: Name Type Description BrainRegion foreign key BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel foreign key CCF.Voxel primary key. Source code in element_electrode_localization/coordinate_framework.py 101 102 103 104 105 106 107 108 109 110 111 class Voxel ( dj . Part ): \"\"\"Voxel information from CCF. Attributes: BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel (foreign key): CCF.Voxel primary key. \"\"\" definition = \"\"\" -> master.BrainRegion -> CCF.Voxel \"\"\" retrieve_acronym ( acronym ) classmethod \u00b6 Retrieve the DataJoint translation of the CCF acronym Source code in element_electrode_localization/coordinate_framework.py 113 114 115 116 @classmethod def retrieve_acronym ( self , acronym ): \"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\" return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , acronym ) . lower () voxel_query ( x = None , y = None , z = None ) classmethod \u00b6 Given one or more coordinates, return unique brain regions Parameters: Name Type Description Default x float x coordinate. None y float y coordinate. None z float z coordinate. None Raises: Type Description ValueError Must specificy at least one dimension. NotImplementedError Coming soon. Source code in element_electrode_localization/coordinate_framework.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @classmethod def voxel_query ( self , x = None , y = None , z = None ): \"\"\"Given one or more coordinates, return unique brain regions Args: x (float): x coordinate. y (float): y coordinate. z (float): z coordinate. Raises: ValueError: Must specificy at least one dimension. NotImplementedError: Coming soon. \"\"\" if not any ( x , y , z ): raise ValueError ( \"Must specify at least one dimension\" ) # query = self.Voxel # TODO: add utility function name lookup raise NotImplementedError ( \"Coming soon\" ) CCF \u00b6 Bases: dj . Lookup Common coordinate framework information. Attributes: Name Type Description ccf_id foreign key, int CCF ID/atlas ID. ccf_version varchar (64) Allen CCF version. ccf_resolution float Voxel resolution in microns. ccf_description varchar (255) CCF label descriptions. Source code in element_electrode_localization/coordinate_framework.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @schema class CCF ( dj . Lookup ): \"\"\"Common coordinate framework information. Attributes: ccf_id (foreign key, int): CCF ID/atlas ID. ccf_version (varchar(64) ): Allen CCF version. ccf_resolution (float): Voxel resolution in microns. ccf_description (varchar(255) ): CCF label descriptions. \"\"\" definition = \"\"\" # Common Coordinate Framework ccf_id : int # CCF ID, a.k.a atlas ID --- ccf_version : varchar(64) # Allen CCF Version - e.g. CCFv3 ccf_resolution : float # voxel resolution in micron ccf_description='': varchar(255) # CCFLabel Description \"\"\" class Voxel ( dj . Part ): \"\"\"CCF voxel coordinates. Attributes: CCF (foreign key): CCF primary key. x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers. y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers. z (foreign key, int): Left-to-right (ML axis) in micrometers. \"\"\" definition = \"\"\" # CCF voxel coordinates -> master x : int # (um) Anterior-to-Posterior (AP axis) y : int # (um) Superior-to-Inferior (DV axis) z : int # (um) Left-to-Right (ML axis) index(y, z) \"\"\" Voxel \u00b6 Bases: dj . Part CCF voxel coordinates. Attributes: Name Type Description CCF foreign key CCF primary key. x foreign key, int Anterior-to-posterior axis (AP axis) in micrometers. y foreign key, int Superior-to_inferior axis (DV axis) in micrometers. z foreign key, int Left-to-right (ML axis) in micrometers. Source code in element_electrode_localization/coordinate_framework.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Voxel ( dj . Part ): \"\"\"CCF voxel coordinates. Attributes: CCF (foreign key): CCF primary key. x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers. y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers. z (foreign key, int): Left-to-right (ML axis) in micrometers. \"\"\" definition = \"\"\" # CCF voxel coordinates -> master x : int # (um) Anterior-to-Posterior (AP axis) y : int # (um) Superior-to-Inferior (DV axis) z : int # (um) Left-to-Right (ML axis) index(y, z) \"\"\" ParentBrainRegion \u00b6 Bases: dj . Lookup Hierarchical structure between the brain regions. Attributes: Name Type Description BrainRegionAnnotation.BrainRegion foreign key BrainRegionAnnotation.BrainRegion primary key. Parent query parent brain region acronym from BrainRegion table Source code in element_electrode_localization/coordinate_framework.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @schema class ParentBrainRegion ( dj . Lookup ): \"\"\"Hierarchical structure between the brain regions. Attributes: BrainRegionAnnotation.BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. Parent (query): parent brain region acronym from BrainRegion table \"\"\" definition = \"\"\" # Hierarchical structure between the brain regionss -> BrainRegionAnnotation.BrainRegion --- -> BrainRegionAnnotation.BrainRegion.proj(parent='acronym') \"\"\" activate ( schema_name , * , create_schema = True , create_tables = True ) \u00b6 Activates the schema. Parameters: Name Type Description Default schema_name str A string containing the name of the probe scehma. required create_schema bool If True, schema will be created in the database. True create_tables bool If True, tables related to the schema will be created in the database. True Source code in element_electrode_localization/coordinate_framework.py 16 17 18 19 20 21 22 23 24 25 26 def activate ( schema_name , * , create_schema = True , create_tables = True ): \"\"\"Activates the schema. Args: schema_name (str): A string containing the name of the probe scehma. create_schema (bool): If True, schema will be created in the database. create_tables (bool): If True, tables related to the schema will be created in the database. \"\"\" schema . activate ( schema_name , create_schema = create_schema , create_tables = create_tables ) load_ccf_annotation ( ccf_id , version_name , voxel_resolution , nrrd_filepath , ontology_csv_filepath ) \u00b6 Load CCF annotation. For an example Allen brain atlas for mouse, see: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017 For the structure/ontology tree, see: https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359 (particularly the ontology file downloadable as CSV) Parameters: Name Type Description Default ccf_id int unique id to identify a new CCF dataset to be inserted. required version_name str CCF version. required voxel_resolution float voxel resolution in microns. required nrrd_filepath str path to the .nrrd file for the volume data. required ontology_csv_filepath str path to the .csv file for the brain region ontology. required Source code in element_electrode_localization/coordinate_framework.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def load_ccf_annotation ( ccf_id , version_name , voxel_resolution , nrrd_filepath , ontology_csv_filepath ): \"\"\"Load CCF annotation. For an example Allen brain atlas for mouse, see: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017 For the structure/ontology tree, see: https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359 (particularly the ontology file downloadable as CSV) Args: ccf_id (int): unique id to identify a new CCF dataset to be inserted. version_name (str): CCF version. voxel_resolution (float): voxel resolution in microns. nrrd_filepath (str): path to the .nrrd file for the volume data. ontology_csv_filepath (str): path to the .csv file for the brain region ontology. \"\"\" ccf_key = { \"ccf_id\" : ccf_id } if CCF & ccf_key : print ( f \"CCF ID { ccf_id } already exists!\" ) return nrrd_filepath = pathlib . Path ( nrrd_filepath ) ontology_csv_filepath = pathlib . Path ( ontology_csv_filepath ) def to_snake_case ( s ): return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , s ) . lower () ontology = pd . read_csv ( ontology_csv_filepath ) stack , hdr = nrrd . read ( nrrd_filepath . as_posix ()) # AP (x), DV (y), ML (z) log . info ( \".. loaded atlas brain volume of shape \" + f \" { stack . shape } from { nrrd_filepath } \" ) ccf_key = { \"ccf_id\" : ccf_id } ccf_entry = { ** ccf_key , \"ccf_version\" : version_name , \"ccf_resolution\" : voxel_resolution , \"ccf_description\" : ( f \"Version: { version_name } \" + f \" - Voxel resolution (uM): { voxel_resolution } \" + f \" - Volume file: { nrrd_filepath . name } \" + \" - Region ontology file: \" + ontology_csv_filepath . name ), } with dj . conn () . transaction : CCF . insert1 ( ccf_entry ) BrainRegionAnnotation . insert1 ( ccf_key ) BrainRegionAnnotation . BrainRegion . insert ( [ dict ( ccf_id = ccf_id , acronym = to_snake_case ( r . acronym ), region_id = r . id , region_name = r . safe_name , color_code = r . color_hex_triplet , ) for _ , r in ontology . iterrows () ] ) # Process voxels per brain region for idx , ( region_id , r ) in enumerate ( tqdm ( ontology . iterrows ())): dj . conn () . ping () region_id = int ( region_id ) log . info ( \".. loading region {} ( {} / {} ) ( {} )\" . format ( region_id , idx , len ( ontology ), r . safe_name ) ) # extracting filled volumes from stack in scaled [[x,y,z]] shape, vol = np . array ( np . where ( stack == region_id )) . T * voxel_resolution vol = pd . DataFrame ( vol , columns = [ \"x\" , \"y\" , \"z\" ]) if not vol . shape [ 0 ]: log . info ( \".. region {} volume: shape {} - skipping\" . format ( region_id , vol . shape ) ) continue else : log . info ( \".. region {} volume: shape {} \" . format ( region_id , vol . shape )) vol [ \"ccf_id\" ] = [ ccf_key [ \"ccf_id\" ]] * len ( vol ) CCF . Voxel . insert ( vol ) vol [ \"acronym\" ] = [ to_snake_case ( r . acronym )] * len ( vol ) BrainRegionAnnotation . Voxel . insert ( vol ) log . info ( \".. done.\" )", "title": "coordinate_framework.py"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation", "text": "Bases: dj . Lookup Brain region annotation. Attributes: Name Type Description CCF foreign key CCF primary key. Source code in element_electrode_localization/coordinate_framework.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @schema class BrainRegionAnnotation ( dj . Lookup ): \"\"\"Brain region annotation. Attributes: CCF (foreign key): CCF primary key. \"\"\" definition = \"\"\" -> CCF \"\"\" class BrainRegion ( dj . Part ): \"\"\"Brain region information. Attributes: BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key. acronym (foreign key, varchar(32) ): Brain region acronym. region_name (varchar(128) ): Brain region full name. region_id (int): Brain region ID. color_code (varchar(6) ): Hexcode of the color code for this region. \"\"\" definition = \"\"\" -> master acronym: varchar(32) # CHARACTER SET utf8 COLLATE utf8_bin --- region_name: varchar(128) region_id=null: int color_code=null: varchar(6) # hexcode of the color code of this region \"\"\" class Voxel ( dj . Part ): \"\"\"Voxel information from CCF. Attributes: BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel (foreign key): CCF.Voxel primary key. \"\"\" definition = \"\"\" -> master.BrainRegion -> CCF.Voxel \"\"\" @classmethod def retrieve_acronym ( self , acronym ): \"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\" return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , acronym ) . lower () @classmethod def voxel_query ( self , x = None , y = None , z = None ): \"\"\"Given one or more coordinates, return unique brain regions Args: x (float): x coordinate. y (float): y coordinate. z (float): z coordinate. Raises: ValueError: Must specificy at least one dimension. NotImplementedError: Coming soon. \"\"\" if not any ( x , y , z ): raise ValueError ( \"Must specify at least one dimension\" ) # query = self.Voxel # TODO: add utility function name lookup raise NotImplementedError ( \"Coming soon\" )", "title": "BrainRegionAnnotation"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.BrainRegion", "text": "Bases: dj . Part Brain region information. Attributes: Name Type Description BrainRegionAnnotation foreign key BrainRegionAnnotation primary key. acronym foreign key, varchar(32) Brain region acronym. region_name varchar (128) Brain region full name. region_id int Brain region ID. color_code varchar (6) Hexcode of the color code for this region. Source code in element_electrode_localization/coordinate_framework.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class BrainRegion ( dj . Part ): \"\"\"Brain region information. Attributes: BrainRegionAnnotation (foreign key): BrainRegionAnnotation primary key. acronym (foreign key, varchar(32) ): Brain region acronym. region_name (varchar(128) ): Brain region full name. region_id (int): Brain region ID. color_code (varchar(6) ): Hexcode of the color code for this region. \"\"\" definition = \"\"\" -> master acronym: varchar(32) # CHARACTER SET utf8 COLLATE utf8_bin --- region_name: varchar(128) region_id=null: int color_code=null: varchar(6) # hexcode of the color code of this region \"\"\"", "title": "BrainRegion"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.Voxel", "text": "Bases: dj . Part Voxel information from CCF. Attributes: Name Type Description BrainRegion foreign key BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel foreign key CCF.Voxel primary key. Source code in element_electrode_localization/coordinate_framework.py 101 102 103 104 105 106 107 108 109 110 111 class Voxel ( dj . Part ): \"\"\"Voxel information from CCF. Attributes: BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. CCF.Voxel (foreign key): CCF.Voxel primary key. \"\"\" definition = \"\"\" -> master.BrainRegion -> CCF.Voxel \"\"\"", "title": "Voxel"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.retrieve_acronym", "text": "Retrieve the DataJoint translation of the CCF acronym Source code in element_electrode_localization/coordinate_framework.py 113 114 115 116 @classmethod def retrieve_acronym ( self , acronym ): \"\"\"Retrieve the DataJoint translation of the CCF acronym\"\"\" return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , acronym ) . lower ()", "title": "retrieve_acronym()"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.BrainRegionAnnotation.voxel_query", "text": "Given one or more coordinates, return unique brain regions Parameters: Name Type Description Default x float x coordinate. None y float y coordinate. None z float z coordinate. None Raises: Type Description ValueError Must specificy at least one dimension. NotImplementedError Coming soon. Source code in element_electrode_localization/coordinate_framework.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 @classmethod def voxel_query ( self , x = None , y = None , z = None ): \"\"\"Given one or more coordinates, return unique brain regions Args: x (float): x coordinate. y (float): y coordinate. z (float): z coordinate. Raises: ValueError: Must specificy at least one dimension. NotImplementedError: Coming soon. \"\"\" if not any ( x , y , z ): raise ValueError ( \"Must specify at least one dimension\" ) # query = self.Voxel # TODO: add utility function name lookup raise NotImplementedError ( \"Coming soon\" )", "title": "voxel_query()"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.CCF", "text": "Bases: dj . Lookup Common coordinate framework information. Attributes: Name Type Description ccf_id foreign key, int CCF ID/atlas ID. ccf_version varchar (64) Allen CCF version. ccf_resolution float Voxel resolution in microns. ccf_description varchar (255) CCF label descriptions. Source code in element_electrode_localization/coordinate_framework.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @schema class CCF ( dj . Lookup ): \"\"\"Common coordinate framework information. Attributes: ccf_id (foreign key, int): CCF ID/atlas ID. ccf_version (varchar(64) ): Allen CCF version. ccf_resolution (float): Voxel resolution in microns. ccf_description (varchar(255) ): CCF label descriptions. \"\"\" definition = \"\"\" # Common Coordinate Framework ccf_id : int # CCF ID, a.k.a atlas ID --- ccf_version : varchar(64) # Allen CCF Version - e.g. CCFv3 ccf_resolution : float # voxel resolution in micron ccf_description='': varchar(255) # CCFLabel Description \"\"\" class Voxel ( dj . Part ): \"\"\"CCF voxel coordinates. Attributes: CCF (foreign key): CCF primary key. x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers. y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers. z (foreign key, int): Left-to-right (ML axis) in micrometers. \"\"\" definition = \"\"\" # CCF voxel coordinates -> master x : int # (um) Anterior-to-Posterior (AP axis) y : int # (um) Superior-to-Inferior (DV axis) z : int # (um) Left-to-Right (ML axis) index(y, z) \"\"\"", "title": "CCF"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.CCF.Voxel", "text": "Bases: dj . Part CCF voxel coordinates. Attributes: Name Type Description CCF foreign key CCF primary key. x foreign key, int Anterior-to-posterior axis (AP axis) in micrometers. y foreign key, int Superior-to_inferior axis (DV axis) in micrometers. z foreign key, int Left-to-right (ML axis) in micrometers. Source code in element_electrode_localization/coordinate_framework.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class Voxel ( dj . Part ): \"\"\"CCF voxel coordinates. Attributes: CCF (foreign key): CCF primary key. x (foreign key, int): Anterior-to-posterior axis (AP axis) in micrometers. y (foreign key, int): Superior-to_inferior axis (DV axis) in micrometers. z (foreign key, int): Left-to-right (ML axis) in micrometers. \"\"\" definition = \"\"\" # CCF voxel coordinates -> master x : int # (um) Anterior-to-Posterior (AP axis) y : int # (um) Superior-to-Inferior (DV axis) z : int # (um) Left-to-Right (ML axis) index(y, z) \"\"\"", "title": "Voxel"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.ParentBrainRegion", "text": "Bases: dj . Lookup Hierarchical structure between the brain regions. Attributes: Name Type Description BrainRegionAnnotation.BrainRegion foreign key BrainRegionAnnotation.BrainRegion primary key. Parent query parent brain region acronym from BrainRegion table Source code in element_electrode_localization/coordinate_framework.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @schema class ParentBrainRegion ( dj . Lookup ): \"\"\"Hierarchical structure between the brain regions. Attributes: BrainRegionAnnotation.BrainRegion (foreign key): BrainRegionAnnotation.BrainRegion primary key. Parent (query): parent brain region acronym from BrainRegion table \"\"\" definition = \"\"\" # Hierarchical structure between the brain regionss -> BrainRegionAnnotation.BrainRegion --- -> BrainRegionAnnotation.BrainRegion.proj(parent='acronym') \"\"\"", "title": "ParentBrainRegion"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.activate", "text": "Activates the schema. Parameters: Name Type Description Default schema_name str A string containing the name of the probe scehma. required create_schema bool If True, schema will be created in the database. True create_tables bool If True, tables related to the schema will be created in the database. True Source code in element_electrode_localization/coordinate_framework.py 16 17 18 19 20 21 22 23 24 25 26 def activate ( schema_name , * , create_schema = True , create_tables = True ): \"\"\"Activates the schema. Args: schema_name (str): A string containing the name of the probe scehma. create_schema (bool): If True, schema will be created in the database. create_tables (bool): If True, tables related to the schema will be created in the database. \"\"\" schema . activate ( schema_name , create_schema = create_schema , create_tables = create_tables )", "title": "activate()"}, {"location": "api/element_electrode_localization/coordinate_framework/#element_electrode_localization.coordinate_framework.load_ccf_annotation", "text": "Load CCF annotation. For an example Allen brain atlas for mouse, see: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017 For the structure/ontology tree, see: https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359 (particularly the ontology file downloadable as CSV) Parameters: Name Type Description Default ccf_id int unique id to identify a new CCF dataset to be inserted. required version_name str CCF version. required voxel_resolution float voxel resolution in microns. required nrrd_filepath str path to the .nrrd file for the volume data. required ontology_csv_filepath str path to the .csv file for the brain region ontology. required Source code in element_electrode_localization/coordinate_framework.py 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def load_ccf_annotation ( ccf_id , version_name , voxel_resolution , nrrd_filepath , ontology_csv_filepath ): \"\"\"Load CCF annotation. For an example Allen brain atlas for mouse, see: http://download.alleninstitute.org/informatics-archive/current-release/mouse_ccf/annotation/ccf_2017 For the structure/ontology tree, see: https://community.brain-map.org/t/allen-mouse-ccf-accessing-and-using-related-data-and-tools/359 (particularly the ontology file downloadable as CSV) Args: ccf_id (int): unique id to identify a new CCF dataset to be inserted. version_name (str): CCF version. voxel_resolution (float): voxel resolution in microns. nrrd_filepath (str): path to the .nrrd file for the volume data. ontology_csv_filepath (str): path to the .csv file for the brain region ontology. \"\"\" ccf_key = { \"ccf_id\" : ccf_id } if CCF & ccf_key : print ( f \"CCF ID { ccf_id } already exists!\" ) return nrrd_filepath = pathlib . Path ( nrrd_filepath ) ontology_csv_filepath = pathlib . Path ( ontology_csv_filepath ) def to_snake_case ( s ): return re . sub ( r \"(?<!^)(?=[A-Z])\" , \"_\" , s ) . lower () ontology = pd . read_csv ( ontology_csv_filepath ) stack , hdr = nrrd . read ( nrrd_filepath . as_posix ()) # AP (x), DV (y), ML (z) log . info ( \".. loaded atlas brain volume of shape \" + f \" { stack . shape } from { nrrd_filepath } \" ) ccf_key = { \"ccf_id\" : ccf_id } ccf_entry = { ** ccf_key , \"ccf_version\" : version_name , \"ccf_resolution\" : voxel_resolution , \"ccf_description\" : ( f \"Version: { version_name } \" + f \" - Voxel resolution (uM): { voxel_resolution } \" + f \" - Volume file: { nrrd_filepath . name } \" + \" - Region ontology file: \" + ontology_csv_filepath . name ), } with dj . conn () . transaction : CCF . insert1 ( ccf_entry ) BrainRegionAnnotation . insert1 ( ccf_key ) BrainRegionAnnotation . BrainRegion . insert ( [ dict ( ccf_id = ccf_id , acronym = to_snake_case ( r . acronym ), region_id = r . id , region_name = r . safe_name , color_code = r . color_hex_triplet , ) for _ , r in ontology . iterrows () ] ) # Process voxels per brain region for idx , ( region_id , r ) in enumerate ( tqdm ( ontology . iterrows ())): dj . conn () . ping () region_id = int ( region_id ) log . info ( \".. loading region {} ( {} / {} ) ( {} )\" . format ( region_id , idx , len ( ontology ), r . safe_name ) ) # extracting filled volumes from stack in scaled [[x,y,z]] shape, vol = np . array ( np . where ( stack == region_id )) . T * voxel_resolution vol = pd . DataFrame ( vol , columns = [ \"x\" , \"y\" , \"z\" ]) if not vol . shape [ 0 ]: log . info ( \".. region {} volume: shape {} - skipping\" . format ( region_id , vol . shape ) ) continue else : log . info ( \".. region {} volume: shape {} \" . format ( region_id , vol . shape )) vol [ \"ccf_id\" ] = [ ccf_key [ \"ccf_id\" ]] * len ( vol ) CCF . Voxel . insert ( vol ) vol [ \"acronym\" ] = [ to_snake_case ( r . acronym )] * len ( vol ) BrainRegionAnnotation . Voxel . insert ( vol ) log . info ( \".. done.\" )", "title": "load_ccf_annotation()"}, {"location": "api/element_electrode_localization/electrode_localization/", "text": "ElectrodePosition \u00b6 Bases: dj . Imported Electrode position information for a probe insertion. Attributes: Name Type Description ProbeInsertion foreign key ProbeInsertion primary key. coodinate_framework.CCF foreign key coordinate_framework.CCF primary key. Source code in element_electrode_localization/electrode_localization.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 @schema class ElectrodePosition ( dj . Imported ): \"\"\"Electrode position information for a probe insertion. Attributes: ProbeInsertion (foreign key): ProbeInsertion primary key. coodinate_framework.CCF (foreign key): coordinate_framework.CCF primary key. \"\"\" definition = \"\"\" -> ProbeInsertion -> coordinate_framework.CCF \"\"\" class Electrode ( dj . Part ): \"\"\"Voxel information for a given electrode. Attributes: master (foreign key): ElectrodePosition primary key. probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema. \"\"\" definition = \"\"\" -> master -> probe.ProbeType.Electrode --- -> coordinate_framework.CCF.Voxel \"\"\" def make ( self , key ): \"\"\"Populates electrode position tables. \"\"\" skipped_electrode_count = 0 voxel_resolution = ( coordinate_framework . CCF & key ) . fetch1 ( \"ccf_resolution\" ) electrode_location_dir = pathlib . Path ( get_electrode_localization_dir ( key )) assert electrode_location_dir . exists () channel_locations_files = list ( electrode_location_dir . glob ( \"*channel_locations*.json\" ) ) electrodes_query = ( probe . ProbeType . Electrode * probe . Probe * ProbeInsertion & key ) probe_type = ( probe . Probe * ProbeInsertion & key ) . fetch1 ( \"probe_type\" ) shanks = np . unique ( electrodes_query . fetch ( \"shank\" )) if len ( channel_locations_files ) == 1 : corresponding_shanks = [ 0 ] if len ( shanks ) != 1 : raise ValueError ( \"Only 1 file found ( {} ) for a {} -shank probe\" . format ( channel_locations_files [ 0 ] . name , len ( shanks ) ) ) if ( \"shank\" in channel_locations_files [ 0 ] . stem and channel_locations_files [ 0 ] . stem [ - 1 ] != 1 ): raise ValueError ( \"The electrode-location file found ( {} ) is \" + \"unexpected for this 1-shank probe\" ) else : if len ( channel_locations_files ) != len ( shanks ): # ensure 1 file per shank raise ValueError ( f \" { len ( channel_locations_files ) } files found for a \" + f \" { len ( shanks ) } -shank probe\" ) corresponding_shanks = [ int ( f . stem [ - 1 ]) for f in channel_locations_files ] # Insertion self . insert1 ( key ) for channel_locations_file , shank_no in zip ( channel_locations_files , corresponding_shanks ): log . debug ( f \"loading channel locations from { channel_locations_file } \" ) with open ( channel_locations_file , \"r\" ) as fh : chn_loc_raw = json . loads ( fh . read ()) chn_loc_data = { \"origin\" : chn_loc_raw [ \"origin\" ]} if len ( chn_loc_data [ \"origin\" ]) > 1 : log . error ( \"More than one origin region found ( {} ). skipping.\" . format ( chn_loc_data [ \"origin\" ] ) ) raise ValueError ( \"More than one origin region found \" + f '( { chn_loc_data [ \"origin\" ] } )' ) # ensuring channel data is sorted; chn_loc_keymap = { int ( k . split ( \"_\" )[ 1 ]): k for k in chn_loc_raw if \"channel_\" in k } chn_loc_data [ \"channels\" ] = np . array ( [ tuple ( chn_loc_raw [ chn_loc_keymap [ k ]] . values ()) for k in sorted ( chn_loc_keymap ) ], dtype = [ ( \"x\" , float ), ( \"y\" , float ), ( \"z\" , float ), ( \"axial\" , float ), ( \"lateral\" , float ), ( \"brain_region_id\" , int ), ( \"brain_region\" , object ), ], ) # get/scale xyz positions pos_xyz_raw = np . array ( [ chn_loc_data [ \"channels\" ][ i ] for i in ( \"x\" , \"y\" , \"z\" )] ) . T pos_origin = next ( iter ( chn_loc_data [ \"origin\" ] . values ())) pos_xyz = np . copy ( pos_xyz_raw ) # by adjusting xyz axes & offsetting from origin position # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below pos_xyz [:, 0 ] = pos_origin [ 1 ] - pos_xyz_raw [:, 1 ] pos_xyz [:, 1 ] = pos_origin [ 0 ] + pos_xyz_raw [:, 0 ] pos_xyz [:, 2 ] = pos_origin [ 2 ] - pos_xyz_raw [:, 2 ] # and quantizing to CCF voxel resolution; pos_xyz = ( voxel_resolution * np . around ( pos_xyz / voxel_resolution )) . astype ( int ) # get recording geometry, probe_electrodes = ( electrodes_query & { \"shank\" : shank_no }) . fetch ( order_by = \"electrode asc\" ) rec_electrodes = np . array ( [ chn_loc_data [ \"channels\" ][ \"lateral\" ], chn_loc_data [ \"channels\" ][ \"axial\" ]] ) . T # adjusting for the lateral offset # npx 1.0 probes has an alternating offset of 0um and 16um between the rows # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows) lateral_offset = np . abs ( np . diff ( ( electrodes_query & { \"shank_col\" : 1 , \"shank\" : shank_no } & \"shank_row in (1, 2)\" ) . fetch ( \"x_coord\" ) )[ 0 ] ) if lateral_offset : rec_electrodes [:, 0 ] = lateral_offset * ( np . floor ( rec_electrodes [:, 0 ] / lateral_offset ) ) # to find corresponding electrodes, elec_coord = np . array ( [ probe_electrodes [ \"x_coord\" ], probe_electrodes [ \"y_coord\" ]] ) . T elec_coord_map = { tuple ( c ): i for i , c in enumerate ( elec_coord )} rec_to_elec_idx = np . array ( [ elec_coord_map [ tuple ( i )] for i in rec_electrodes ] ) for electrode , x , y , z in zip ( probe_electrodes [ rec_to_elec_idx ][ \"electrode\" ], pos_xyz [:, 0 ], pos_xyz [:, 1 ], pos_xyz [:, 2 ], ): entry = { ** key , \"electrode\" : electrode , \"x\" : x , \"y\" : y , \"z\" : z , \"probe_type\" : probe_type , } try : self . Electrode . insert1 ( entry ) except dj . IntegrityError as e : skipped_electrode_count += 1 log . warning ( \"...... ElectrodePositionError at X=\" + f \" { x } , Y= { y } , Z= { z } : \\n { repr ( e ) } \" ) if skipped_electrode_count > 0 : log . info ( f \"Skipped { skipped_electrode_count } electrodes for \\n\\t { key } \" ) Electrode \u00b6 Bases: dj . Part Voxel information for a given electrode. Attributes: Name Type Description master foreign key ElectrodePosition primary key. probe.ProbeType.Electrode foreign key probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel query fetches Voxel information from coordinate_framework schema. Source code in element_electrode_localization/electrode_localization.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class Electrode ( dj . Part ): \"\"\"Voxel information for a given electrode. Attributes: master (foreign key): ElectrodePosition primary key. probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema. \"\"\" definition = \"\"\" -> master -> probe.ProbeType.Electrode --- -> coordinate_framework.CCF.Voxel \"\"\" make ( key ) \u00b6 Populates electrode position tables. Source code in element_electrode_localization/electrode_localization.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def make ( self , key ): \"\"\"Populates electrode position tables. \"\"\" skipped_electrode_count = 0 voxel_resolution = ( coordinate_framework . CCF & key ) . fetch1 ( \"ccf_resolution\" ) electrode_location_dir = pathlib . Path ( get_electrode_localization_dir ( key )) assert electrode_location_dir . exists () channel_locations_files = list ( electrode_location_dir . glob ( \"*channel_locations*.json\" ) ) electrodes_query = ( probe . ProbeType . Electrode * probe . Probe * ProbeInsertion & key ) probe_type = ( probe . Probe * ProbeInsertion & key ) . fetch1 ( \"probe_type\" ) shanks = np . unique ( electrodes_query . fetch ( \"shank\" )) if len ( channel_locations_files ) == 1 : corresponding_shanks = [ 0 ] if len ( shanks ) != 1 : raise ValueError ( \"Only 1 file found ( {} ) for a {} -shank probe\" . format ( channel_locations_files [ 0 ] . name , len ( shanks ) ) ) if ( \"shank\" in channel_locations_files [ 0 ] . stem and channel_locations_files [ 0 ] . stem [ - 1 ] != 1 ): raise ValueError ( \"The electrode-location file found ( {} ) is \" + \"unexpected for this 1-shank probe\" ) else : if len ( channel_locations_files ) != len ( shanks ): # ensure 1 file per shank raise ValueError ( f \" { len ( channel_locations_files ) } files found for a \" + f \" { len ( shanks ) } -shank probe\" ) corresponding_shanks = [ int ( f . stem [ - 1 ]) for f in channel_locations_files ] # Insertion self . insert1 ( key ) for channel_locations_file , shank_no in zip ( channel_locations_files , corresponding_shanks ): log . debug ( f \"loading channel locations from { channel_locations_file } \" ) with open ( channel_locations_file , \"r\" ) as fh : chn_loc_raw = json . loads ( fh . read ()) chn_loc_data = { \"origin\" : chn_loc_raw [ \"origin\" ]} if len ( chn_loc_data [ \"origin\" ]) > 1 : log . error ( \"More than one origin region found ( {} ). skipping.\" . format ( chn_loc_data [ \"origin\" ] ) ) raise ValueError ( \"More than one origin region found \" + f '( { chn_loc_data [ \"origin\" ] } )' ) # ensuring channel data is sorted; chn_loc_keymap = { int ( k . split ( \"_\" )[ 1 ]): k for k in chn_loc_raw if \"channel_\" in k } chn_loc_data [ \"channels\" ] = np . array ( [ tuple ( chn_loc_raw [ chn_loc_keymap [ k ]] . values ()) for k in sorted ( chn_loc_keymap ) ], dtype = [ ( \"x\" , float ), ( \"y\" , float ), ( \"z\" , float ), ( \"axial\" , float ), ( \"lateral\" , float ), ( \"brain_region_id\" , int ), ( \"brain_region\" , object ), ], ) # get/scale xyz positions pos_xyz_raw = np . array ( [ chn_loc_data [ \"channels\" ][ i ] for i in ( \"x\" , \"y\" , \"z\" )] ) . T pos_origin = next ( iter ( chn_loc_data [ \"origin\" ] . values ())) pos_xyz = np . copy ( pos_xyz_raw ) # by adjusting xyz axes & offsetting from origin position # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below pos_xyz [:, 0 ] = pos_origin [ 1 ] - pos_xyz_raw [:, 1 ] pos_xyz [:, 1 ] = pos_origin [ 0 ] + pos_xyz_raw [:, 0 ] pos_xyz [:, 2 ] = pos_origin [ 2 ] - pos_xyz_raw [:, 2 ] # and quantizing to CCF voxel resolution; pos_xyz = ( voxel_resolution * np . around ( pos_xyz / voxel_resolution )) . astype ( int ) # get recording geometry, probe_electrodes = ( electrodes_query & { \"shank\" : shank_no }) . fetch ( order_by = \"electrode asc\" ) rec_electrodes = np . array ( [ chn_loc_data [ \"channels\" ][ \"lateral\" ], chn_loc_data [ \"channels\" ][ \"axial\" ]] ) . T # adjusting for the lateral offset # npx 1.0 probes has an alternating offset of 0um and 16um between the rows # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows) lateral_offset = np . abs ( np . diff ( ( electrodes_query & { \"shank_col\" : 1 , \"shank\" : shank_no } & \"shank_row in (1, 2)\" ) . fetch ( \"x_coord\" ) )[ 0 ] ) if lateral_offset : rec_electrodes [:, 0 ] = lateral_offset * ( np . floor ( rec_electrodes [:, 0 ] / lateral_offset ) ) # to find corresponding electrodes, elec_coord = np . array ( [ probe_electrodes [ \"x_coord\" ], probe_electrodes [ \"y_coord\" ]] ) . T elec_coord_map = { tuple ( c ): i for i , c in enumerate ( elec_coord )} rec_to_elec_idx = np . array ( [ elec_coord_map [ tuple ( i )] for i in rec_electrodes ] ) for electrode , x , y , z in zip ( probe_electrodes [ rec_to_elec_idx ][ \"electrode\" ], pos_xyz [:, 0 ], pos_xyz [:, 1 ], pos_xyz [:, 2 ], ): entry = { ** key , \"electrode\" : electrode , \"x\" : x , \"y\" : y , \"z\" : z , \"probe_type\" : probe_type , } try : self . Electrode . insert1 ( entry ) except dj . IntegrityError as e : skipped_electrode_count += 1 log . warning ( \"...... ElectrodePositionError at X=\" + f \" { x } , Y= { y } , Z= { z } : \\n { repr ( e ) } \" ) if skipped_electrode_count > 0 : log . info ( f \"Skipped { skipped_electrode_count } electrodes for \\n\\t { key } \" ) activate ( electrode_localization_schema_name , coordinate_framework_schema_name = None , * , create_schema = True , create_tables = True , linking_module = None ) \u00b6 Activates the electrode_localization and coordinate_framework schemas. Parameters: Name Type Description Default electrode_localization_schema_name str A string containing the name of the electrode_localization schema. required coordinate_framework_schema_name str A string containing the name of the coordinate_framework schema. None create_schema bool If True, schema will be created in the database. True create_tables bool If True, tables related to the schema will be created in the database. True linking_module str A string containing the module name or module containing the required dependencies to activate the schema. None Source code in element_electrode_localization/electrode_localization.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def activate ( electrode_localization_schema_name , coordinate_framework_schema_name = None , * , create_schema = True , create_tables = True , linking_module = None , ): \"\"\"Activates the `electrode_localization` and `coordinate_framework` schemas. Args: electrode_localization_schema_name (str): A string containing the name of the electrode_localization schema. coordinate_framework_schema_name (str): A string containing the name of the coordinate_framework schema. create_schema (bool): If True, schema will be created in the database. create_tables (bool): If True, tables related to the schema will be created in the database. linking_module (str): A string containing the module name or module containing the required dependencies to activate the schema. \"\"\" if isinstance ( linking_module , str ): linking_module = importlib . import_module ( linking_module ) assert inspect . ismodule ( linking_module ), \"The argument 'dependency' must be a module's name or a module\" global _linking_module , ProbeInsertion , probe _linking_module = linking_module ProbeInsertion = _linking_module . ProbeInsertion probe = _linking_module . probe # activate coordinate_framework . activate ( coordinate_framework_schema_name , create_schema = create_schema , create_tables = create_tables , ) schema . activate ( electrode_localization_schema_name , create_schema = create_schema , create_tables = create_tables , add_objects = _linking_module . __dict__ , ) get_electrode_localization_dir ( probe_insertion_key ) \u00b6 Retrieve the electrode localization directory associated with a ProbeInsertion. The directory should contain channel_locations.json files (one per shank)for the corresponding probe_insertion_key . Parameters: Name Type Description Default probe_insertion_key dict key of a ProbeInsertion. required Returns: Type Description str The full file-path of the electrode localization dir. Source code in element_electrode_localization/electrode_localization.py 66 67 68 69 70 71 72 73 74 75 76 77 def get_electrode_localization_dir ( probe_insertion_key : dict ) -> str : \"\"\"Retrieve the electrode localization directory associated with a ProbeInsertion. The directory should contain `channel_locations.json` files (one per shank)for the corresponding `probe_insertion_key`. Args: probe_insertion_key (dict): key of a ProbeInsertion. Returns: The full file-path of the electrode localization dir. \"\"\" return _linking_module . get_electrode_localization_dir ( probe_insertion_key )", "title": "electrode_localization.py"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition", "text": "Bases: dj . Imported Electrode position information for a probe insertion. Attributes: Name Type Description ProbeInsertion foreign key ProbeInsertion primary key. coodinate_framework.CCF foreign key coordinate_framework.CCF primary key. Source code in element_electrode_localization/electrode_localization.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 @schema class ElectrodePosition ( dj . Imported ): \"\"\"Electrode position information for a probe insertion. Attributes: ProbeInsertion (foreign key): ProbeInsertion primary key. coodinate_framework.CCF (foreign key): coordinate_framework.CCF primary key. \"\"\" definition = \"\"\" -> ProbeInsertion -> coordinate_framework.CCF \"\"\" class Electrode ( dj . Part ): \"\"\"Voxel information for a given electrode. Attributes: master (foreign key): ElectrodePosition primary key. probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema. \"\"\" definition = \"\"\" -> master -> probe.ProbeType.Electrode --- -> coordinate_framework.CCF.Voxel \"\"\" def make ( self , key ): \"\"\"Populates electrode position tables. \"\"\" skipped_electrode_count = 0 voxel_resolution = ( coordinate_framework . CCF & key ) . fetch1 ( \"ccf_resolution\" ) electrode_location_dir = pathlib . Path ( get_electrode_localization_dir ( key )) assert electrode_location_dir . exists () channel_locations_files = list ( electrode_location_dir . glob ( \"*channel_locations*.json\" ) ) electrodes_query = ( probe . ProbeType . Electrode * probe . Probe * ProbeInsertion & key ) probe_type = ( probe . Probe * ProbeInsertion & key ) . fetch1 ( \"probe_type\" ) shanks = np . unique ( electrodes_query . fetch ( \"shank\" )) if len ( channel_locations_files ) == 1 : corresponding_shanks = [ 0 ] if len ( shanks ) != 1 : raise ValueError ( \"Only 1 file found ( {} ) for a {} -shank probe\" . format ( channel_locations_files [ 0 ] . name , len ( shanks ) ) ) if ( \"shank\" in channel_locations_files [ 0 ] . stem and channel_locations_files [ 0 ] . stem [ - 1 ] != 1 ): raise ValueError ( \"The electrode-location file found ( {} ) is \" + \"unexpected for this 1-shank probe\" ) else : if len ( channel_locations_files ) != len ( shanks ): # ensure 1 file per shank raise ValueError ( f \" { len ( channel_locations_files ) } files found for a \" + f \" { len ( shanks ) } -shank probe\" ) corresponding_shanks = [ int ( f . stem [ - 1 ]) for f in channel_locations_files ] # Insertion self . insert1 ( key ) for channel_locations_file , shank_no in zip ( channel_locations_files , corresponding_shanks ): log . debug ( f \"loading channel locations from { channel_locations_file } \" ) with open ( channel_locations_file , \"r\" ) as fh : chn_loc_raw = json . loads ( fh . read ()) chn_loc_data = { \"origin\" : chn_loc_raw [ \"origin\" ]} if len ( chn_loc_data [ \"origin\" ]) > 1 : log . error ( \"More than one origin region found ( {} ). skipping.\" . format ( chn_loc_data [ \"origin\" ] ) ) raise ValueError ( \"More than one origin region found \" + f '( { chn_loc_data [ \"origin\" ] } )' ) # ensuring channel data is sorted; chn_loc_keymap = { int ( k . split ( \"_\" )[ 1 ]): k for k in chn_loc_raw if \"channel_\" in k } chn_loc_data [ \"channels\" ] = np . array ( [ tuple ( chn_loc_raw [ chn_loc_keymap [ k ]] . values ()) for k in sorted ( chn_loc_keymap ) ], dtype = [ ( \"x\" , float ), ( \"y\" , float ), ( \"z\" , float ), ( \"axial\" , float ), ( \"lateral\" , float ), ( \"brain_region_id\" , int ), ( \"brain_region\" , object ), ], ) # get/scale xyz positions pos_xyz_raw = np . array ( [ chn_loc_data [ \"channels\" ][ i ] for i in ( \"x\" , \"y\" , \"z\" )] ) . T pos_origin = next ( iter ( chn_loc_data [ \"origin\" ] . values ())) pos_xyz = np . copy ( pos_xyz_raw ) # by adjusting xyz axes & offsetting from origin position # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below pos_xyz [:, 0 ] = pos_origin [ 1 ] - pos_xyz_raw [:, 1 ] pos_xyz [:, 1 ] = pos_origin [ 0 ] + pos_xyz_raw [:, 0 ] pos_xyz [:, 2 ] = pos_origin [ 2 ] - pos_xyz_raw [:, 2 ] # and quantizing to CCF voxel resolution; pos_xyz = ( voxel_resolution * np . around ( pos_xyz / voxel_resolution )) . astype ( int ) # get recording geometry, probe_electrodes = ( electrodes_query & { \"shank\" : shank_no }) . fetch ( order_by = \"electrode asc\" ) rec_electrodes = np . array ( [ chn_loc_data [ \"channels\" ][ \"lateral\" ], chn_loc_data [ \"channels\" ][ \"axial\" ]] ) . T # adjusting for the lateral offset # npx 1.0 probes has an alternating offset of 0um and 16um between the rows # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows) lateral_offset = np . abs ( np . diff ( ( electrodes_query & { \"shank_col\" : 1 , \"shank\" : shank_no } & \"shank_row in (1, 2)\" ) . fetch ( \"x_coord\" ) )[ 0 ] ) if lateral_offset : rec_electrodes [:, 0 ] = lateral_offset * ( np . floor ( rec_electrodes [:, 0 ] / lateral_offset ) ) # to find corresponding electrodes, elec_coord = np . array ( [ probe_electrodes [ \"x_coord\" ], probe_electrodes [ \"y_coord\" ]] ) . T elec_coord_map = { tuple ( c ): i for i , c in enumerate ( elec_coord )} rec_to_elec_idx = np . array ( [ elec_coord_map [ tuple ( i )] for i in rec_electrodes ] ) for electrode , x , y , z in zip ( probe_electrodes [ rec_to_elec_idx ][ \"electrode\" ], pos_xyz [:, 0 ], pos_xyz [:, 1 ], pos_xyz [:, 2 ], ): entry = { ** key , \"electrode\" : electrode , \"x\" : x , \"y\" : y , \"z\" : z , \"probe_type\" : probe_type , } try : self . Electrode . insert1 ( entry ) except dj . IntegrityError as e : skipped_electrode_count += 1 log . warning ( \"...... ElectrodePositionError at X=\" + f \" { x } , Y= { y } , Z= { z } : \\n { repr ( e ) } \" ) if skipped_electrode_count > 0 : log . info ( f \"Skipped { skipped_electrode_count } electrodes for \\n\\t { key } \" )", "title": "ElectrodePosition"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition.Electrode", "text": "Bases: dj . Part Voxel information for a given electrode. Attributes: Name Type Description master foreign key ElectrodePosition primary key. probe.ProbeType.Electrode foreign key probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel query fetches Voxel information from coordinate_framework schema. Source code in element_electrode_localization/electrode_localization.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 class Electrode ( dj . Part ): \"\"\"Voxel information for a given electrode. Attributes: master (foreign key): ElectrodePosition primary key. probe.ProbeType.Electrode (foreign key): probe.ProbeType.Electrode primary key. coordinate_framework.CCF.Voxel (query): fetches Voxel information from coordinate_framework schema. \"\"\" definition = \"\"\" -> master -> probe.ProbeType.Electrode --- -> coordinate_framework.CCF.Voxel \"\"\"", "title": "Electrode"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.ElectrodePosition.make", "text": "Populates electrode position tables. Source code in element_electrode_localization/electrode_localization.py 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def make ( self , key ): \"\"\"Populates electrode position tables. \"\"\" skipped_electrode_count = 0 voxel_resolution = ( coordinate_framework . CCF & key ) . fetch1 ( \"ccf_resolution\" ) electrode_location_dir = pathlib . Path ( get_electrode_localization_dir ( key )) assert electrode_location_dir . exists () channel_locations_files = list ( electrode_location_dir . glob ( \"*channel_locations*.json\" ) ) electrodes_query = ( probe . ProbeType . Electrode * probe . Probe * ProbeInsertion & key ) probe_type = ( probe . Probe * ProbeInsertion & key ) . fetch1 ( \"probe_type\" ) shanks = np . unique ( electrodes_query . fetch ( \"shank\" )) if len ( channel_locations_files ) == 1 : corresponding_shanks = [ 0 ] if len ( shanks ) != 1 : raise ValueError ( \"Only 1 file found ( {} ) for a {} -shank probe\" . format ( channel_locations_files [ 0 ] . name , len ( shanks ) ) ) if ( \"shank\" in channel_locations_files [ 0 ] . stem and channel_locations_files [ 0 ] . stem [ - 1 ] != 1 ): raise ValueError ( \"The electrode-location file found ( {} ) is \" + \"unexpected for this 1-shank probe\" ) else : if len ( channel_locations_files ) != len ( shanks ): # ensure 1 file per shank raise ValueError ( f \" { len ( channel_locations_files ) } files found for a \" + f \" { len ( shanks ) } -shank probe\" ) corresponding_shanks = [ int ( f . stem [ - 1 ]) for f in channel_locations_files ] # Insertion self . insert1 ( key ) for channel_locations_file , shank_no in zip ( channel_locations_files , corresponding_shanks ): log . debug ( f \"loading channel locations from { channel_locations_file } \" ) with open ( channel_locations_file , \"r\" ) as fh : chn_loc_raw = json . loads ( fh . read ()) chn_loc_data = { \"origin\" : chn_loc_raw [ \"origin\" ]} if len ( chn_loc_data [ \"origin\" ]) > 1 : log . error ( \"More than one origin region found ( {} ). skipping.\" . format ( chn_loc_data [ \"origin\" ] ) ) raise ValueError ( \"More than one origin region found \" + f '( { chn_loc_data [ \"origin\" ] } )' ) # ensuring channel data is sorted; chn_loc_keymap = { int ( k . split ( \"_\" )[ 1 ]): k for k in chn_loc_raw if \"channel_\" in k } chn_loc_data [ \"channels\" ] = np . array ( [ tuple ( chn_loc_raw [ chn_loc_keymap [ k ]] . values ()) for k in sorted ( chn_loc_keymap ) ], dtype = [ ( \"x\" , float ), ( \"y\" , float ), ( \"z\" , float ), ( \"axial\" , float ), ( \"lateral\" , float ), ( \"brain_region_id\" , int ), ( \"brain_region\" , object ), ], ) # get/scale xyz positions pos_xyz_raw = np . array ( [ chn_loc_data [ \"channels\" ][ i ] for i in ( \"x\" , \"y\" , \"z\" )] ) . T pos_origin = next ( iter ( chn_loc_data [ \"origin\" ] . values ())) pos_xyz = np . copy ( pos_xyz_raw ) # by adjusting xyz axes & offsetting from origin position # in \"pos_xyz_raw\", x-axis and y-axis are swapped, correcting for that below pos_xyz [:, 0 ] = pos_origin [ 1 ] - pos_xyz_raw [:, 1 ] pos_xyz [:, 1 ] = pos_origin [ 0 ] + pos_xyz_raw [:, 0 ] pos_xyz [:, 2 ] = pos_origin [ 2 ] - pos_xyz_raw [:, 2 ] # and quantizing to CCF voxel resolution; pos_xyz = ( voxel_resolution * np . around ( pos_xyz / voxel_resolution )) . astype ( int ) # get recording geometry, probe_electrodes = ( electrodes_query & { \"shank\" : shank_no }) . fetch ( order_by = \"electrode asc\" ) rec_electrodes = np . array ( [ chn_loc_data [ \"channels\" ][ \"lateral\" ], chn_loc_data [ \"channels\" ][ \"axial\" ]] ) . T # adjusting for the lateral offset # npx 1.0 probes has an alternating offset of 0um and 16um between the rows # npx 2.0 probes do not have this offset (i.e. offset = 0um for all rows) lateral_offset = np . abs ( np . diff ( ( electrodes_query & { \"shank_col\" : 1 , \"shank\" : shank_no } & \"shank_row in (1, 2)\" ) . fetch ( \"x_coord\" ) )[ 0 ] ) if lateral_offset : rec_electrodes [:, 0 ] = lateral_offset * ( np . floor ( rec_electrodes [:, 0 ] / lateral_offset ) ) # to find corresponding electrodes, elec_coord = np . array ( [ probe_electrodes [ \"x_coord\" ], probe_electrodes [ \"y_coord\" ]] ) . T elec_coord_map = { tuple ( c ): i for i , c in enumerate ( elec_coord )} rec_to_elec_idx = np . array ( [ elec_coord_map [ tuple ( i )] for i in rec_electrodes ] ) for electrode , x , y , z in zip ( probe_electrodes [ rec_to_elec_idx ][ \"electrode\" ], pos_xyz [:, 0 ], pos_xyz [:, 1 ], pos_xyz [:, 2 ], ): entry = { ** key , \"electrode\" : electrode , \"x\" : x , \"y\" : y , \"z\" : z , \"probe_type\" : probe_type , } try : self . Electrode . insert1 ( entry ) except dj . IntegrityError as e : skipped_electrode_count += 1 log . warning ( \"...... ElectrodePositionError at X=\" + f \" { x } , Y= { y } , Z= { z } : \\n { repr ( e ) } \" ) if skipped_electrode_count > 0 : log . info ( f \"Skipped { skipped_electrode_count } electrodes for \\n\\t { key } \" )", "title": "make()"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.activate", "text": "Activates the electrode_localization and coordinate_framework schemas. Parameters: Name Type Description Default electrode_localization_schema_name str A string containing the name of the electrode_localization schema. required coordinate_framework_schema_name str A string containing the name of the coordinate_framework schema. None create_schema bool If True, schema will be created in the database. True create_tables bool If True, tables related to the schema will be created in the database. True linking_module str A string containing the module name or module containing the required dependencies to activate the schema. None Source code in element_electrode_localization/electrode_localization.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def activate ( electrode_localization_schema_name , coordinate_framework_schema_name = None , * , create_schema = True , create_tables = True , linking_module = None , ): \"\"\"Activates the `electrode_localization` and `coordinate_framework` schemas. Args: electrode_localization_schema_name (str): A string containing the name of the electrode_localization schema. coordinate_framework_schema_name (str): A string containing the name of the coordinate_framework schema. create_schema (bool): If True, schema will be created in the database. create_tables (bool): If True, tables related to the schema will be created in the database. linking_module (str): A string containing the module name or module containing the required dependencies to activate the schema. \"\"\" if isinstance ( linking_module , str ): linking_module = importlib . import_module ( linking_module ) assert inspect . ismodule ( linking_module ), \"The argument 'dependency' must be a module's name or a module\" global _linking_module , ProbeInsertion , probe _linking_module = linking_module ProbeInsertion = _linking_module . ProbeInsertion probe = _linking_module . probe # activate coordinate_framework . activate ( coordinate_framework_schema_name , create_schema = create_schema , create_tables = create_tables , ) schema . activate ( electrode_localization_schema_name , create_schema = create_schema , create_tables = create_tables , add_objects = _linking_module . __dict__ , )", "title": "activate()"}, {"location": "api/element_electrode_localization/electrode_localization/#element_electrode_localization.electrode_localization.get_electrode_localization_dir", "text": "Retrieve the electrode localization directory associated with a ProbeInsertion. The directory should contain channel_locations.json files (one per shank)for the corresponding probe_insertion_key . Parameters: Name Type Description Default probe_insertion_key dict key of a ProbeInsertion. required Returns: Type Description str The full file-path of the electrode localization dir. Source code in element_electrode_localization/electrode_localization.py 66 67 68 69 70 71 72 73 74 75 76 77 def get_electrode_localization_dir ( probe_insertion_key : dict ) -> str : \"\"\"Retrieve the electrode localization directory associated with a ProbeInsertion. The directory should contain `channel_locations.json` files (one per shank)for the corresponding `probe_insertion_key`. Args: probe_insertion_key (dict): key of a ProbeInsertion. Returns: The full file-path of the electrode localization dir. \"\"\" return _linking_module . get_electrode_localization_dir ( probe_insertion_key )", "title": "get_electrode_localization_dir()"}, {"location": "api/element_electrode_localization/version/", "text": "Package metadata.", "title": "version.py"}]}